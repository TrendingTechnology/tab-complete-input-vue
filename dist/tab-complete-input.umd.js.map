{"version":3,"file":"tab-complete-input.umd.js","sources":["../src/lib/trie.js","../src/tab-complete-input.js"],"sourcesContent":["/**\r\n* Copyright (C) 2012 Paul Thurlow\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy \r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n* \r\n* The above copyright notice and this permission notice shall be included in\r\n* all copies or substantial portions of the Software.\r\n* \r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n*/\r\n\r\n/**\r\n* @decription Trie class for saving data by keywords accessible through\r\n*   word prefixes\r\n* @class\r\n* @version 0.1.5\r\n*/\r\nconst Triejs = function(opts) {\r\n\r\n  /**\r\n  * @private\r\n  * @description Options for trie implementation\r\n  * @type {Object}\r\n  */\r\n  this.options = {\r\n  \r\n    /**\r\n    * @description Maximum number of items to cache per node\r\n    * @type {Number}\r\n    */\r\n    maxCache: 10\r\n\r\n    /**\r\n    * @description Whether to handle caching on node levels\r\n    * @type {Boolean}\r\n    */\r\n    , enableCache: true\r\n\r\n    /**\r\n    * @description Maintain insert ordering when adding to non cached trie\r\n    * @type {Boolean}\r\n    */\r\n    , insertOrder: false\r\n\r\n    /**\r\n    * @description Return responses from root when requests is empty\r\n    * @type {Boolean}\r\n    */\r\n    , returnRoot: false\r\n\r\n    /**\r\n    * @description Insert function for adding new items to cache\r\n    * @type {Function}\r\n    */\r\n    , insert: null\r\n\r\n    /**\r\n    * @description Sorting function for sorting items to cache\r\n    * @type {Function}\r\n    */\r\n    , sort: null\r\n\r\n    /**\r\n    * @description Clip function for removing old items from cache\r\n    * @type {Function}\r\n    */\r\n    , clip: null\r\n\r\n    /**\r\n    * @description copy function for copying data between nodes\r\n    * @type {Function}\r\n    */\r\n    , copy: null\r\n\r\n    /**\r\n    * @description Merge function to merge two data sets together\r\n    * @type {Function}\r\n    */\r\n    , merge: null\r\n  };\r\n\r\n  /**\r\n  * @private\r\n  * @description trie object\r\n  * @type {Object}\r\n  */\r\n  this.root = {};\r\n\r\n  /**\r\n  * @private\r\n  * @description insert order index\r\n  * @type {Number}\r\n  */\r\n  this.index = 0;\r\n\r\n  // mixin optional override options\r\n  for (var key in opts) {\r\n    if (opts.hasOwnProperty(key)) {\r\n      this.options[key] = opts[key];\r\n    }\r\n  };\r\n\r\n  if (typeof this.options.insert != 'function') {\r\n    this.options.insert = function(target, data) {\r\n      // if maintaining insert ordering add a order index on insert\r\n      if (this.options.insertOrder \r\n        && typeof data.d === 'undefined' \r\n        && typeof data.o === 'undefined') {\r\n        data = { d: data, o: this.index++ };\r\n      }\r\n      if (target && target.length) {\r\n        target.push(data);\r\n      } else {\r\n        target = [data];\r\n      }\r\n      return target;\r\n    };\r\n  }\r\n  if (typeof this.options.sort != 'function') {\r\n    if (!this.options.insertOrder) {\r\n      this.options.sort = function() {\r\n        this.sort();\r\n      };\r\n    } else if (this.options.insertOrder) {\r\n      this.options.sort = function() {\r\n        this.sort(function(a, b) { return a.o - b.o; });\r\n      }\r\n    }\r\n  }\r\n  if (typeof this.options.clip != 'function') {\r\n    this.options.clip = function(max) {\r\n      if (this.length > max) {\r\n        this.splice(max, this.length - max);\r\n      }\r\n    };\r\n  }\r\n  if (typeof this.options.copy != 'function') {\r\n    this.options.copy = function(data) {\r\n      return data.slice(0);\r\n    }\r\n  }\r\n  if (typeof this.options.merge != 'function') {\r\n    this.options.merge = function(target, data, word) {\r\n      for (var i = 0, ii = data.length; i < ii; i++) {\r\n        target = this.options.insert.call(this, target, data[i]);\r\n        this.options.sort.call(target, word);\r\n        this.options.clip.call(target, this.options.maxCache);\r\n      }\r\n      return target;\r\n    }\r\n  }\r\n};\r\n\r\nTriejs.prototype = {\r\n\r\n  /*-------------------------------------------------------------------------\r\n  * Private Functions\r\n  -------------------------------------------------------------------------*/\r\n\r\n  /**\r\n  * @description Add data to the current nodes cache\r\n  * @param curr {Object} current node in trie\r\n  * @param data {Object} Data to add to the cache\r\n  * @private\r\n  */\r\n  _addCacheData: function(curr, data) {\r\n    if ((this.root === curr && !this.options.returnRoot) \r\n      || this.options.enableCache === false) {\r\n      return false;\r\n    }\r\n    if (!curr.$d) {\r\n      curr.$d = {};\r\n    }\r\n    curr.$d = this.options.insert.call(this, curr.$d, data);\r\n    this.options.sort.call(curr.$d);\r\n    this.options.clip.call(curr.$d, this.options.maxCache);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @description Adds the remainder of a word to a subtree\r\n  * @param suffix {String} the remainder of a word\r\n  * @param data {Object} data to add at suffix\r\n  * @param curr {Object} current node in the trie\r\n  * @private\r\n  */\r\n  , _addSuffix: function(suffix, data, curr) {\r\n    var letter = suffix.charAt(0)\r\n      , nextSuffix = suffix.substring(1) || null\r\n      , opts = { $d: {} };\r\n    if (nextSuffix) {\r\n      opts.$s = nextSuffix;\r\n    }\r\n    if (typeof curr[letter] === 'undefined') {\r\n      curr[letter] = opts;\r\n    } else if (typeof curr[letter].$d === 'undefined') {\r\n      curr[letter].$d = {};\r\n      if (nextSuffix && typeof curr[letter].$s === 'undefined') {\r\n        curr[letter].$s = nextSuffix;\r\n      }\r\n    }\r\n    curr[letter].$d = this.options.insert.call(this, curr[letter].$d, data);\r\n    this.options.sort.call(curr[letter].$d);\r\n  }\r\n\r\n  /**\r\n  * @description Move data from current location to new suffix position\r\n  * @param suffix {String} the remainder of a word\r\n  * @param data {Object} data currently stored to be moved to suffix ending\r\n  * @param curr {Object} current node in the trie\r\n  * @private\r\n  */\r\n  , _moveSuffix: function(suffix, data, curr) {\r\n    var letter = suffix.charAt(0)\r\n      , nextSuffix = suffix.substring(1) || null\r\n      , opts = { $d: {} };\r\n    if (nextSuffix) {\r\n      opts.$s = nextSuffix;\r\n    }\r\n    if (typeof curr[letter] === 'undefined') {\r\n      curr[letter] = opts;\r\n    }\r\n    curr[letter].$d = this.options.copy(data);\r\n  }\r\n\r\n  /**\r\n  * @description Get data from a given node, either in the cache\r\n  *   or by parsing the subtree\r\n  * @param node {Object} The node to get data from\r\n  * @return {Array|Object} data results\r\n  */\r\n  , _getDataAtNode: function(node, word) {\r\n    var data;\r\n\r\n    if (this.options.enableCache) {\r\n      this.options.sort.call(node.$d, word);\r\n      data = node.$d;\r\n    } else {\r\n      data = this._getSubtree(node, word);\r\n    }\r\n    if (this.options.insertOrder) {\r\n      data = this._stripInsertOrder(data);\r\n    }\r\n    return data ? this.options.copy(data) : undefined;\r\n  }\r\n\r\n  /**\r\n  * @description Remove the outer data later that stores insert order\r\n  * @param data {Object} The data with insert order object wrapper\r\n  * @return {Array} data results without insert order wrapper\r\n  */\r\n  , _stripInsertOrder: function(data) {\r\n    if (typeof data == 'undefined') {\r\n      return;\r\n    }\r\n    var temp = [];\r\n    for (var i = 0, ii = data.length; i < ii; i++) {\r\n      temp.push(data[i].d);\r\n    }\r\n    return temp;\r\n  }\r\n\r\n  /**\r\n  * @description Get the subtree data of a trie traversing depth first\r\n  * @param curr {Object} current node in the trie to get data under\r\n  * @return {Object} data from the subtree\r\n  */\r\n  , _getSubtree: function(curr, word) {\r\n    var res\r\n      , nodeArray = [curr]\r\n      , node;\r\n    while (node = nodeArray.pop()) {\r\n      for (var newNode in node) {\r\n        if (node.hasOwnProperty(newNode)) {\r\n          if (newNode == '$d') {\r\n            if (typeof res == 'undefined') {\r\n              res = [];\r\n            }\r\n            res = this.options.merge.call(this, res, node.$d, word);\r\n          } else if (newNode != '$s') {\r\n            nodeArray.push(node[newNode]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /*-------------------------------------------------------------------------\r\n  * Public Functions\r\n  -------------------------------------------------------------------------*/\r\n\r\n  /**\r\n  * @description Adds a word into the trie\r\n  * @param word {String} word to add\r\n  * @param data {Object} data to store under given term\r\n  */\r\n  , add: function(word, data) {\r\n    if (typeof word != 'string') { return false; }\r\n    if (arguments.length == 1) { data = word; }\r\n    word = word.toLowerCase();\r\n\r\n    var curr = this.root;\r\n\r\n    for (var i = 0, ii = word.length; i < ii; i++) {\r\n      var letter = word.charAt(i);\r\n      // No letter at this level\r\n      if (!curr[letter]) {\r\n        // Current level has a suffix already so push suffix lower in trie\r\n        if (curr.$s) {\r\n          if (curr.$s == word.substring(i)) {\r\n            // special case where word exists already, so we avoid breaking\r\n            // up the substring and store both at the top level\r\n            if (!this._addCacheData(curr, data)) {\r\n              curr.$d = this.options.insert.call(this, curr.$d, data);\r\n              this.options.sort.call(curr.$d);\r\n            }\r\n            break;\r\n          }\r\n          this._moveSuffix(curr.$s, curr.$d, curr);\r\n          delete curr.$s;\r\n          if (this.options.enableCache === false) {\r\n            delete curr.$d;\r\n          }\r\n        }\r\n        // Current level has no sub letter after building suffix\r\n        if (!curr[letter]) {\r\n          this._addSuffix(word.substring(i), data, curr);\r\n          this._addCacheData(curr, data);\r\n          break;\r\n        }\r\n        // add to the cache at the current node level in the trie\r\n        this._addCacheData(curr, data);\r\n        // if its the end of a word push possible suffixes at this node down\r\n        // and add data to cache at the words end\r\n        if (i == ii - 1) {\r\n          if (curr[letter].$s) {\r\n            this._moveSuffix(curr[letter].$s, curr[letter].$d, curr[letter]);\r\n            delete curr[letter].$s;\r\n            if (this.options.enableCache === false) {\r\n              delete curr[letter].$d;\r\n            }\r\n            // insert new data at current end of word node level\r\n            this._addSuffix(letter, data, curr);\r\n          } else {\r\n            // either add to cache or just add the data at end of word node\r\n            if (!this._addCacheData(curr[letter], data)) {\r\n              this._addSuffix(letter, data, curr);\r\n            }\r\n          }\r\n        }\r\n        curr = curr[letter];\r\n      }\r\n      // There is a letter and we are at the end of the word\r\n      else if (i == ii - 1) {\r\n        this._addCacheData(curr, data);\r\n        // either add to cache at the end of the word or just add the data\r\n        if (!this._addCacheData(curr[letter], data)) {\r\n          this._addSuffix(letter, data, curr);\r\n        }\r\n      }\r\n      // There is a letter so traverse lower into the trie\r\n      else {\r\n        this._addCacheData(curr, data);\r\n        curr = curr[letter];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * @description remove a word from the trie if there is no caching\r\n  * @param word {String} word to remove from the trie\r\n  */\r\n  , remove: function(word) {\r\n    if (typeof word !== 'string' || word === '' || this.options.enableCache){\r\n      return;\r\n    }\r\n    word = word.toLowerCase();\r\n    var letter\r\n      , i\r\n      , ii\r\n      , curr = this.root\r\n      , prev\r\n      , prevLetter\r\n      , data\r\n      , count = 0;\r\n\r\n    for (i = 0, ii = word.length; i < ii; i++) {\r\n      letter = word.charAt(i);\r\n      if (!curr[letter]) {\r\n        if (curr.$s && curr.$s === word.substring(i)) {\r\n          break; // word is at this leaf node\r\n        } else {\r\n          return; // word not in the trie\r\n        }\r\n      } else {\r\n        prev = curr;\r\n        prevLetter = letter;\r\n        curr = curr[letter]\r\n      }\r\n    }\r\n    data = this.options.copy(curr.$d);\r\n    if (this.options.insertOrder) {\r\n      data = this._stripInsertOrder(data);\r\n    }\r\n    delete curr.$d;\r\n    delete curr.$s;\r\n    // enumerate all child nodes\r\n    for (var node in curr) {\r\n      if (curr.hasOwnProperty(node)) {\r\n        count++;\r\n      }\r\n    }\r\n    if (!count) {\r\n      delete prev[prevLetter]; // nothing left at this level so remove it\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /**\r\n  * @description see if a word has been added to the trie\r\n  * @param word {String} word to search for\r\n  * @return {Boolean} whether word exists or not\r\n  */\r\n  , contains: function(word) {\r\n    if (typeof word !== 'string' || word == '') { return false; }\r\n    word = word.toLowerCase();\r\n\r\n    var curr = this.root;\r\n    for (var i = 0, ii = word.length; i < ii; i++) {\r\n      var letter = word.charAt(i);\r\n      if (!curr[letter]) {\r\n        if (curr.$s && curr.$s === word.substring(i)) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      } else {\r\n        curr = curr[letter];\r\n      }\r\n    }\r\n    return curr.$d && (typeof curr.$s === 'undefined') ? true : false;\r\n  }\r\n\r\n  /**\r\n  * @description Get the data for a given prefix of a word\r\n  * @param prefix {String} string of the prefix of a word\r\n  * @return {Object} data for the given prefix\r\n  */\r\n  , find: function(prefix) {\r\n    if (typeof prefix !== 'string') { return undefined; }\r\n    if (prefix == '' && !this.options.returnRoot) { return undefined; }\r\n    prefix = prefix.toLowerCase();\r\n\r\n    var curr = this.root;\r\n    for (var i = 0, ii = prefix.length; i < ii; i++) {\r\n      var letter = prefix.charAt(i);\r\n      if (!curr[letter]) {\r\n        if (curr.$s && curr.$s.indexOf(prefix.substring(i)) == 0) {\r\n          return this._getDataAtNode(curr, prefix);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      } else {\r\n        curr = curr[letter];\r\n      }\r\n    }\r\n    return this._getDataAtNode(curr, prefix);\r\n  }\r\n};\r\n\r\n//Export to CommonJS/Node format\r\nexport default Triejs","import TrieJS from \"./lib/trie\";\r\n\r\nexport default {\r\n  name: \"tab-complete-input\",\r\n  data () {\r\n    return {\r\n      trie: {},\r\n      position: 0,\r\n      wordPos: 0,\r\n      index: 0,\r\n      words: [],\r\n      word: \"\",\r\n      dynamicData: false,\r\n      possible: false,\r\n      saved: false,\r\n      localValue: this.value\r\n    };\r\n  },\r\n  render (h) {\r\n    var self = this\r\n    return h('input', {\r\n      ref: 'input',\r\n      attrs: {\r\n        ...self.$props\r\n      },\r\n      domProps: {\r\n        value: self.value\r\n      },\r\n      directives: [\r\n        { name: 'model', rawName: 'v-model', value: self.localValue, expression: 'value' }\r\n      ],\r\n      on: {\r\n        ...self.$listeners,\r\n        keydown: self.$listeners.keydown ? [ self.tabComplete, self.$listeners.keydown ] : self.tabComplete,\r\n        input (event) {\r\n          self.localValue = event.target.value\r\n          self.$emit('input', event.target.value)\r\n        }\r\n      }\r\n    })\r\n  },\r\n  created () {\r\n    this.dynamicData = this.dataSource instanceof Function;\r\n\r\n    if (!this.dynamicData) {\r\n      this.setData(this.dataSource);\r\n    }\r\n  },\r\n  props: {\r\n    dataSource: {\r\n      default: [],\r\n    },\r\n    format: {\r\n      default: function (val, prev, pos) { return {word: val, prev: prev } },\r\n      type: Function\r\n    }, \r\n    value: {\r\n      default: \"\", \r\n      type: String\r\n    }\r\n  },\r\n  methods: {\r\n    setData (array) {\r\n      this.trie = new TrieJS();\r\n      array.forEach(element => {\r\n        this.trie.add(element);\r\n      });\r\n    },\r\n\r\n    async tabComplete (e) {\r\n      if (e && e.keyCode !== 9) {\r\n        this.saved = false;\r\n        this.index = 0;\r\n\r\n        return\r\n      }\r\n      if (!this.saved) {\r\n        this.position = this.getCursorPos();\r\n        const newValue = this.localValue.slice(0, this.position) + \" \" + this.localValue.slice(this.position);\r\n        \r\n        this.words = newValue.split(\" \");\r\n        var lcount = 0;\r\n        for (var i = 0; i < this.words.length; i++) {\r\n          var w = this.words[i];\r\n          lcount += w.length + 1;\r\n          if (lcount >= this.position) {\r\n            this.word = this.words[i];\r\n            this.wordPos = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (this.word != \"\" && e) {\r\n          e.preventDefault();\r\n        }\r\n\r\n        if (this.dynamicData) {\r\n          let data = this.dataSource(this.word, this.wordPos);\r\n          var array = await data;\r\n          this.setData(array);\r\n        }\r\n\r\n        this.saved = true;\r\n        this.possible = this.trie.find(this.word);\r\n      } else {\r\n        this.index++;\r\n      }\r\n\r\n      if (this.possible && this.index >= this.possible.length) {\r\n        this.index = 0;\r\n      }\r\n\r\n      if (this.possible) {\r\n        if (e) e.preventDefault();\r\n        let dupe = this.words;\r\n        let completion = this.possible[this.index];\r\n        let prev = \"\";\r\n\r\n        if (dupe.length > 1) {\r\n          prev = dupe[this.wordPos - 1];\r\n        }\r\n\r\n        let res = this.format(completion, prev, this.wordPos);\r\n        dupe[this.wordPos] = res.word;\r\n        if (res.prev) dupe[this.wordPos - 1] = res.prev;\r\n\r\n        let newPos = this.words.slice(0, this.wordPos + 1).join(\" \").length;\r\n        this.localValue = dupe.join(\" \");\r\n        this.localValue = this.localValue.slice(0, newPos) + this.localValue.slice(newPos + 1)\r\n        this.updateValue(this.localValue);\r\n        this.selectRange(newPos, newPos);\r\n      }\r\n    },\r\n\r\n    updateValue (value) {\r\n      this.localValue = value\r\n      this.$emit('input', value)\r\n    }, \r\n\r\n    selectRange (start, end) {\r\n      this.$el.focus();\r\n      this.$el.setSelectionRange(start, end);\r\n    },\r\n\r\n    getCursorPos () {\r\n      return this.$el.selectionStart;\r\n    }\r\n  }\r\n}\r\n"],"names":["const","Triejs","opts","key","options","maxCache","enableCache","insertOrder","returnRoot","insert","sort","clip","copy","merge","root","index","hasOwnProperty","this","target","data","d","o","length","push","a","b","max","splice","slice","word","i","ii","call","prototype","_addCacheData","curr","$d","_addSuffix","suffix","letter","charAt","nextSuffix","substring","$s","_moveSuffix","_getDataAtNode","node","_getSubtree","_stripInsertOrder","undefined","temp","res","nodeArray","pop","newNode","add","arguments","toLowerCase","remove","prev","prevLetter","count","contains","find","prefix","indexOf","name","trie","position","wordPos","words","dynamicData","possible","saved","localValue","value","render","h","self","ref","attrs","Object","$props","domProps","directives","rawName","expression","on","$listeners","keydown","tabComplete","input","event","$emit","created","dataSource","Function","setData","props","default","format","val","pos","type","String","methods","array","TrieJS","forEach","element","e","_this","preventDefault","dupe","newPos","join","updateValue","selectRange","keyCode","getCursorPos","newValue","split","lcount","start","end","$el","focus","setSelectionRange","selectionStart"],"mappings":"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"}