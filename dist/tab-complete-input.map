{"version":3,"sources":["lib/trie.js","tab-complete-input.js"],"names":["Triejs","opts","key","options","maxCache","enableCache","insertOrder","returnRoot","insert","sort","clip","copy","merge","root","index","hasOwnProperty","target","data","d","o","length","push","a","b","max","splice","slice","word","i","ii","call","prototype","_addCacheData","curr","$d","_addSuffix","suffix","letter","charAt","nextSuffix","substring","$s","_moveSuffix","_getDataAtNode","node","_getSubtree","_stripInsertOrder","undefined","temp","res","nodeArray","pop","newNode","add","arguments","toLowerCase","remove","prev","prevLetter","count","contains","find","prefix","indexOf","exports","module","define","amd","name","trie","position","wordPos","words","dynamicData","possible","saved","localValue","value","render","h","self","ref","attrs","$props","domProps","directives","rawName","expression","on","$listeners","keydown","tabComplete","input","event","$emit","created","dataSource","Function","setData","props","default","format","val","pos","type","String","methods","array","TrieJS","forEach","element","e","keyCode","getCursorPos","newValue","split","lcount","w","preventDefault","dupe","completion","newPos","join","updateValue","selectRange","start","end","$el","focus","setSelectionRange","selectionStart"],"mappings":"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","file":"tab-complete-input.map","sourceRoot":"../src","sourcesContent":["/**\n* Copyright (C) 2012 Paul Thurlow\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy \n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n(function() {\n\n  /**\n  * @decription Trie class for saving data by keywords accessible through\n  *   word prefixes\n  * @class\n  * @version 0.1.5\n  */\n  var Triejs = function(opts) {\n\n    /**\n    * @private\n    * @description Options for trie implementation\n    * @type {Object}\n    */\n    this.options = {\n    \n      /**\n      * @description Maximum number of items to cache per node\n      * @type {Number}\n      */\n      maxCache: 10\n\n      /**\n      * @description Whether to handle caching on node levels\n      * @type {Boolean}\n      */\n      , enableCache: true\n\n      /**\n      * @description Maintain insert ordering when adding to non cached trie\n      * @type {Boolean}\n      */\n      , insertOrder: false\n\n      /**\n      * @description Return responses from root when requests is empty\n      * @type {Boolean}\n      */\n      , returnRoot: false\n\n      /**\n      * @description Insert function for adding new items to cache\n      * @type {Function}\n      */\n      , insert: null\n\n      /**\n      * @description Sorting function for sorting items to cache\n      * @type {Function}\n      */\n      , sort: null\n\n      /**\n      * @description Clip function for removing old items from cache\n      * @type {Function}\n      */\n      , clip: null\n\n      /**\n      * @description copy function for copying data between nodes\n      * @type {Function}\n      */\n      , copy: null\n\n      /**\n      * @description Merge function to merge two data sets together\n      * @type {Function}\n      */\n      , merge: null\n    };\n\n    /**\n    * @private\n    * @description trie object\n    * @type {Object}\n    */\n    this.root = {};\n\n    /**\n    * @private\n    * @description insert order index\n    * @type {Number}\n    */\n    this.index = 0;\n\n    // mixin optional override options\n    for (var key in opts) {\n      if (opts.hasOwnProperty(key)) {\n        this.options[key] = opts[key];\n      }\n    };\n\n    if (typeof this.options.insert != 'function') {\n      this.options.insert = function(target, data) {\n        // if maintaining insert ordering add a order index on insert\n        if (this.options.insertOrder \n          && typeof data.d === 'undefined' \n          && typeof data.o === 'undefined') {\n          data = { d: data, o: this.index++ };\n        }\n        if (target && target.length) {\n          target.push(data);\n        } else {\n          target = [data];\n        }\n        return target;\n      };\n    }\n    if (typeof this.options.sort != 'function') {\n      if (!this.options.insertOrder) {\n        this.options.sort = function() {\n          this.sort();\n        };\n      } else if (this.options.insertOrder) {\n        this.options.sort = function() {\n          this.sort(function(a, b) { return a.o - b.o; });\n        }\n      }\n    }\n    if (typeof this.options.clip != 'function') {\n      this.options.clip = function(max) {\n        if (this.length > max) {\n          this.splice(max, this.length - max);\n        }\n      };\n    }\n    if (typeof this.options.copy != 'function') {\n      this.options.copy = function(data) {\n        return data.slice(0);\n      }\n    }\n    if (typeof this.options.merge != 'function') {\n      this.options.merge = function(target, data, word) {\n        for (var i = 0, ii = data.length; i < ii; i++) {\n          target = this.options.insert.call(this, target, data[i]);\n          this.options.sort.call(target, word);\n          this.options.clip.call(target, this.options.maxCache);\n        }\n        return target;\n      }\n    }\n  };\n\n  Triejs.prototype = {\n\n    /*-------------------------------------------------------------------------\n    * Private Functions\n    -------------------------------------------------------------------------*/\n\n    /**\n    * @description Add data to the current nodes cache\n    * @param curr {Object} current node in trie\n    * @param data {Object} Data to add to the cache\n    * @private\n    */\n    _addCacheData: function(curr, data) {\n      if ((this.root === curr && !this.options.returnRoot) \n        || this.options.enableCache === false) {\n        return false;\n      }\n      if (!curr.$d) {\n        curr.$d = {};\n      }\n      curr.$d = this.options.insert.call(this, curr.$d, data);\n      this.options.sort.call(curr.$d);\n      this.options.clip.call(curr.$d, this.options.maxCache);\n      return true;\n    }\n\n    /**\n    * @description Adds the remainder of a word to a subtree\n    * @param suffix {String} the remainder of a word\n    * @param data {Object} data to add at suffix\n    * @param curr {Object} current node in the trie\n    * @private\n    */\n    , _addSuffix: function(suffix, data, curr) {\n      var letter = suffix.charAt(0)\n        , nextSuffix = suffix.substring(1) || null\n        , opts = { $d: {} };\n      if (nextSuffix) {\n        opts.$s = nextSuffix;\n      }\n      if (typeof curr[letter] === 'undefined') {\n        curr[letter] = opts;\n      } else if (typeof curr[letter].$d === 'undefined') {\n        curr[letter].$d = {};\n        if (nextSuffix && typeof curr[letter].$s === 'undefined') {\n          curr[letter].$s = nextSuffix;\n        }\n      }\n      curr[letter].$d = this.options.insert.call(this, curr[letter].$d, data);\n      this.options.sort.call(curr[letter].$d);\n    }\n\n    /**\n    * @description Move data from current location to new suffix position\n    * @param suffix {String} the remainder of a word\n    * @param data {Object} data currently stored to be moved to suffix ending\n    * @param curr {Object} current node in the trie\n    * @private\n    */\n    , _moveSuffix: function(suffix, data, curr) {\n      var letter = suffix.charAt(0)\n        , nextSuffix = suffix.substring(1) || null\n        , opts = { $d: {} };\n      if (nextSuffix) {\n        opts.$s = nextSuffix;\n      }\n      if (typeof curr[letter] === 'undefined') {\n        curr[letter] = opts;\n      }\n      curr[letter].$d = this.options.copy(data);\n    }\n\n    /**\n    * @description Get data from a given node, either in the cache\n    *   or by parsing the subtree\n    * @param node {Object} The node to get data from\n    * @return {Array|Object} data results\n    */\n    , _getDataAtNode: function(node, word) {\n      var data;\n\n      if (this.options.enableCache) {\n        this.options.sort.call(node.$d, word);\n        data = node.$d;\n      } else {\n        data = this._getSubtree(node, word);\n      }\n      if (this.options.insertOrder) {\n        data = this._stripInsertOrder(data);\n      }\n      return data ? this.options.copy(data) : undefined;\n    }\n\n    /**\n    * @description Remove the outer data later that stores insert order\n    * @param data {Object} The data with insert order object wrapper\n    * @return {Array} data results without insert order wrapper\n    */\n    , _stripInsertOrder: function(data) {\n      if (typeof data == 'undefined') {\n        return;\n      }\n      var temp = [];\n      for (var i = 0, ii = data.length; i < ii; i++) {\n        temp.push(data[i].d);\n      }\n      return temp;\n    }\n\n    /**\n    * @description Get the subtree data of a trie traversing depth first\n    * @param curr {Object} current node in the trie to get data under\n    * @return {Object} data from the subtree\n    */\n    , _getSubtree: function(curr, word) {\n      var res\n        , nodeArray = [curr]\n        , node;\n      while (node = nodeArray.pop()) {\n        for (var newNode in node) {\n          if (node.hasOwnProperty(newNode)) {\n            if (newNode == '$d') {\n              if (typeof res == 'undefined') {\n                res = [];\n              }\n              res = this.options.merge.call(this, res, node.$d, word);\n            } else if (newNode != '$s') {\n              nodeArray.push(node[newNode]);\n            }\n          }\n        }\n      }\n      return res;\n    }\n\n    /*-------------------------------------------------------------------------\n    * Public Functions\n    -------------------------------------------------------------------------*/\n\n    /**\n    * @description Adds a word into the trie\n    * @param word {String} word to add\n    * @param data {Object} data to store under given term\n    */\n    , add: function(word, data) {\n      if (typeof word != 'string') { return false; }\n      if (arguments.length == 1) { data = word; }\n      word = word.toLowerCase();\n\n      var curr = this.root;\n\n      for (var i = 0, ii = word.length; i < ii; i++) {\n        var letter = word.charAt(i);\n        // No letter at this level\n        if (!curr[letter]) {\n          // Current level has a suffix already so push suffix lower in trie\n          if (curr.$s) {\n            if (curr.$s == word.substring(i)) {\n              // special case where word exists already, so we avoid breaking\n              // up the substring and store both at the top level\n              if (!this._addCacheData(curr, data)) {\n                curr.$d = this.options.insert.call(this, curr.$d, data);\n                this.options.sort.call(curr.$d);\n              }\n              break;\n            }\n            this._moveSuffix(curr.$s, curr.$d, curr);\n            delete curr.$s;\n            if (this.options.enableCache === false) {\n              delete curr.$d;\n            }\n          }\n          // Current level has no sub letter after building suffix\n          if (!curr[letter]) {\n            this._addSuffix(word.substring(i), data, curr);\n            this._addCacheData(curr, data);\n            break;\n          }\n          // add to the cache at the current node level in the trie\n          this._addCacheData(curr, data);\n          // if its the end of a word push possible suffixes at this node down\n          // and add data to cache at the words end\n          if (i == ii - 1) {\n            if (curr[letter].$s) {\n              this._moveSuffix(curr[letter].$s, curr[letter].$d, curr[letter]);\n              delete curr[letter].$s;\n              if (this.options.enableCache === false) {\n                delete curr[letter].$d;\n              }\n              // insert new data at current end of word node level\n              this._addSuffix(letter, data, curr);\n            } else {\n              // either add to cache or just add the data at end of word node\n              if (!this._addCacheData(curr[letter], data)) {\n                this._addSuffix(letter, data, curr);\n              }\n            }\n          }\n          curr = curr[letter];\n        }\n        // There is a letter and we are at the end of the word\n        else if (i == ii - 1) {\n          this._addCacheData(curr, data);\n          // either add to cache at the end of the word or just add the data\n          if (!this._addCacheData(curr[letter], data)) {\n            this._addSuffix(letter, data, curr);\n          }\n        }\n        // There is a letter so traverse lower into the trie\n        else {\n          this._addCacheData(curr, data);\n          curr = curr[letter];\n        }\n      }\n    }\n\n    /**\n    * @description remove a word from the trie if there is no caching\n    * @param word {String} word to remove from the trie\n    */\n    , remove: function(word) {\n      if (typeof word !== 'string' || word === '' || this.options.enableCache){\n        return;\n      }\n      word = word.toLowerCase();\n      var letter\n        , i\n        , ii\n        , curr = this.root\n        , prev\n        , prevLetter\n        , data\n        , count = 0;\n\n      for (i = 0, ii = word.length; i < ii; i++) {\n        letter = word.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s === word.substring(i)) {\n            break; // word is at this leaf node\n          } else {\n            return; // word not in the trie\n          }\n        } else {\n          prev = curr;\n          prevLetter = letter;\n          curr = curr[letter]\n        }\n      }\n      data = this.options.copy(curr.$d);\n      if (this.options.insertOrder) {\n        data = this._stripInsertOrder(data);\n      }\n      delete curr.$d;\n      delete curr.$s;\n      // enumerate all child nodes\n      for (var node in curr) {\n        if (curr.hasOwnProperty(node)) {\n          count++;\n        }\n      }\n      if (!count) {\n        delete prev[prevLetter]; // nothing left at this level so remove it\n      }\n      return data;\n    }\n\n    /**\n    * @description see if a word has been added to the trie\n    * @param word {String} word to search for\n    * @return {Boolean} whether word exists or not\n    */\n    , contains: function(word) {\n      if (typeof word !== 'string' || word == '') { return false; }\n      word = word.toLowerCase();\n\n      var curr = this.root;\n      for (var i = 0, ii = word.length; i < ii; i++) {\n        var letter = word.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s === word.substring(i)) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          curr = curr[letter];\n        }\n      }\n      return curr.$d && (typeof curr.$s === 'undefined') ? true : false;\n    }\n\n    /**\n    * @description Get the data for a given prefix of a word\n    * @param prefix {String} string of the prefix of a word\n    * @return {Object} data for the given prefix\n    */\n    , find: function(prefix) {\n      if (typeof prefix !== 'string') { return undefined; }\n      if (prefix == '' && !this.options.returnRoot) { return undefined; }\n      prefix = prefix.toLowerCase();\n\n      var curr = this.root;\n      for (var i = 0, ii = prefix.length; i < ii; i++) {\n        var letter = prefix.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s.indexOf(prefix.substring(i)) == 0) {\n            return this._getDataAtNode(curr, prefix);\n          } else {\n            return undefined;\n          }\n        } else {\n          curr = curr[letter];\n        }\n      }\n      return this._getDataAtNode(curr, prefix);\n    }\n  };\n\n  //Export to CommonJS/Node format\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = Triejs;\n    }\n    exports.Triejs = Triejs;\n  } else if (typeof define === 'function' && define.amd) {\n    define('triejs', function() {\n      return Triejs;\n    });\n  } else {\n    // no exports so attach to global\n    this['Triejs'] = Triejs;\n  }\n})(this);","import TrieJS from \"./lib/trie\";\n\nexport default {\n  name: \"tab-complete-input\",\n  data () {\n    return {\n      trie: {},\n      position: 0,\n      wordPos: 0,\n      index: 0,\n      words: [],\n      word: \"\",\n      dynamicData: false,\n      possible: false,\n      saved: false,\n      localValue: this.value\n    };\n  },\n  render (h) {\n    var self = this\n    return h('input', {\n      ref: 'input',\n      attrs: {\n        ...self.$props\n      },\n      domProps: {\n        value: self.value\n      },\n      directives: [\n        { name: 'model', rawName: 'v-model', value: self.localValue, expression: 'value' }\n      ],\n      on: {\n        ...self.$listeners,\n        keydown: self.$listeners.keydown ? [ self.tabComplete, self.$listeners.keydown ] : self.tabComplete,\n        input (event) {\n          self.localValue = event.target.value\n          self.$emit('input', event.target.value)\n        }\n      }\n    })\n  },\n  created () {\n    this.dynamicData = this.dataSource instanceof Function;\n\n    if (!this.dynamicData) {\n      this.setData(this.dataSource);\n    }\n  },\n  props: {\n    dataSource: {\n      default: [],\n    },\n    format: {\n      default: function (val, prev, pos) { return {word: val, prev: prev } },\n      type: Function\n    }, \n    value: {\n      default: \"\", \n      type: String\n    }\n  },\n  methods: {\n    setData (array) {\n      this.trie = new TrieJS();\n      array.forEach(element => {\n        this.trie.add(element);\n      });\n    },\n\n    async tabComplete (e) {\n      if (e && e.keyCode !== 9) {\n        this.saved = false;\n        this.index = 0;\n\n        return\n      }\n      if (!this.saved) {\n        this.position = this.getCursorPos();\n        const newValue = this.localValue.slice(0, this.position) + \" \" + this.localValue.slice(this.position);\n        \n        this.words = newValue.split(\" \");\n        var lcount = 0;\n        for (var i = 0; i < this.words.length; i++) {\n          var w = this.words[i];\n          lcount += w.length + 1;\n          if (lcount >= this.position) {\n            this.word = this.words[i];\n            this.wordPos = i;\n            break;\n          }\n        }\n\n        if (this.word != \"\" && e) {\n          e.preventDefault();\n        }\n\n        if (this.dynamicData) {\n          let data = this.dataSource(this.word, this.wordPos);\n          var array = await data;\n          this.setData(array);\n        }\n\n        this.saved = true;\n        this.possible = this.trie.find(this.word);\n      } else {\n        this.index++;\n      }\n\n      if (this.possible && this.index >= this.possible.length) {\n        this.index = 0;\n      }\n\n      if (this.possible) {\n        if (e) e.preventDefault();\n        let dupe = this.words;\n        let completion = this.possible[this.index];\n        let prev = \"\";\n\n        if (dupe.length > 1) {\n          prev = dupe[this.wordPos - 1];\n        }\n\n        let res = this.format(completion, prev, this.wordPos);\n        dupe[this.wordPos] = res.word;\n        if (res.prev) dupe[this.wordPos - 1] = res.prev;\n\n        let newPos = this.words.slice(0, this.wordPos + 1).join(\" \").length;\n        this.localValue = dupe.join(\" \");\n        this.localValue = this.localValue.slice(0, newPos) + this.localValue.slice(newPos + 1)\n        this.updateValue(this.localValue);\n        this.selectRange(newPos, newPos);\n      }\n    },\n\n    updateValue (value) {\n      this.localValue = value\n      this.$emit('input', value)\n    }, \n\n    selectRange (start, end) {\n      this.$el.focus();\n      this.$el.setSelectionRange(start, end);\n    },\n\n    getCursorPos () {\n      return this.$el.selectionStart;\n    }\n  }\n}\n"]}