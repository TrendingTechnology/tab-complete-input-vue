{"version":3,"sources":["../node_modules/triejs/src/trie.js","tab-complete-input.vue"],"names":[],"mappings":"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","file":"tab-complete-input.map","sourceRoot":"..\\src","sourcesContent":["/**\n* Copyright (C) 2012 Paul Thurlow\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy \n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n(function() {\n\n  /**\n  * @decription Trie class for saving data by keywords accessible through\n  *   word prefixes\n  * @class\n  * @version 0.1.5\n  */\n  var Triejs = function(opts) {\n\n    /**\n    * @private\n    * @description Options for trie implementation\n    * @type {Object}\n    */\n    this.options = {\n    \n      /**\n      * @description Maximum number of items to cache per node\n      * @type {Number}\n      */\n      maxCache: 10\n\n      /**\n      * @description Whether to handle caching on node levels\n      * @type {Boolean}\n      */\n      , enableCache: true\n\n      /**\n      * @description Maintain insert ordering when adding to non cached trie\n      * @type {Boolean}\n      */\n      , insertOrder: false\n\n      /**\n      * @description Return responses from root when requests is empty\n      * @type {Boolean}\n      */\n      , returnRoot: false\n\n      /**\n      * @description Insert function for adding new items to cache\n      * @type {Function}\n      */\n      , insert: null\n\n      /**\n      * @description Sorting function for sorting items to cache\n      * @type {Function}\n      */\n      , sort: null\n\n      /**\n      * @description Clip function for removing old items from cache\n      * @type {Function}\n      */\n      , clip: null\n\n      /**\n      * @description copy function for copying data between nodes\n      * @type {Function}\n      */\n      , copy: null\n\n      /**\n      * @description Merge function to merge two data sets together\n      * @type {Function}\n      */\n      , merge: null\n    };\n\n    /**\n    * @private\n    * @description trie object\n    * @type {Object}\n    */\n    this.root = {};\n\n    /**\n    * @private\n    * @description insert order index\n    * @type {Number}\n    */\n    this.index = 0;\n\n    // mixin optional override options\n    for (var key in opts) {\n      if (opts.hasOwnProperty(key)) {\n        this.options[key] = opts[key];\n      }\n    };\n\n    if (typeof this.options.insert != 'function') {\n      this.options.insert = function(target, data) {\n        // if maintaining insert ordering add a order index on insert\n        if (this.options.insertOrder \n          && typeof data.d === 'undefined' \n          && typeof data.o === 'undefined') {\n          data = { d: data, o: this.index++ };\n        }\n        if (target && target.length) {\n          target.push(data);\n        } else {\n          target = [data];\n        }\n        return target;\n      };\n    }\n    if (typeof this.options.sort != 'function') {\n      if (!this.options.insertOrder) {\n        this.options.sort = function() {\n          this.sort();\n        };\n      } else if (this.options.insertOrder) {\n        this.options.sort = function() {\n          this.sort(function(a, b) { return a.o - b.o; });\n        }\n      }\n    }\n    if (typeof this.options.clip != 'function') {\n      this.options.clip = function(max) {\n        if (this.length > max) {\n          this.splice(max, this.length - max);\n        }\n      };\n    }\n    if (typeof this.options.copy != 'function') {\n      this.options.copy = function(data) {\n        return data.slice(0);\n      }\n    }\n    if (typeof this.options.merge != 'function') {\n      this.options.merge = function(target, data, word) {\n        for (var i = 0, ii = data.length; i < ii; i++) {\n          target = this.options.insert.call(this, target, data[i]);\n          this.options.sort.call(target, word);\n          this.options.clip.call(target, this.options.maxCache);\n        }\n        return target;\n      }\n    }\n  };\n\n  Triejs.prototype = {\n\n    /*-------------------------------------------------------------------------\n    * Private Functions\n    -------------------------------------------------------------------------*/\n\n    /**\n    * @description Add data to the current nodes cache\n    * @param curr {Object} current node in trie\n    * @param data {Object} Data to add to the cache\n    * @private\n    */\n    _addCacheData: function(curr, data) {\n      if ((this.root === curr && !this.options.returnRoot) \n        || this.options.enableCache === false) {\n        return false;\n      }\n      if (!curr.$d) {\n        curr.$d = {};\n      }\n      curr.$d = this.options.insert.call(this, curr.$d, data);\n      this.options.sort.call(curr.$d);\n      this.options.clip.call(curr.$d, this.options.maxCache);\n      return true;\n    }\n\n    /**\n    * @description Adds the remainder of a word to a subtree\n    * @param suffix {String} the remainder of a word\n    * @param data {Object} data to add at suffix\n    * @param curr {Object} current node in the trie\n    * @private\n    */\n    , _addSuffix: function(suffix, data, curr) {\n      var letter = suffix.charAt(0)\n        , nextSuffix = suffix.substring(1) || null\n        , opts = { $d: {} };\n      if (nextSuffix) {\n        opts.$s = nextSuffix;\n      }\n      if (typeof curr[letter] === 'undefined') {\n        curr[letter] = opts;\n      } else if (typeof curr[letter].$d === 'undefined') {\n        curr[letter].$d = {};\n        if (nextSuffix && typeof curr[letter].$s === 'undefined') {\n          curr[letter].$s = nextSuffix;\n        }\n      }\n      curr[letter].$d = this.options.insert.call(this, curr[letter].$d, data);\n      this.options.sort.call(curr[letter].$d);\n    }\n\n    /**\n    * @description Move data from current location to new suffix position\n    * @param suffix {String} the remainder of a word\n    * @param data {Object} data currently stored to be moved to suffix ending\n    * @param curr {Object} current node in the trie\n    * @private\n    */\n    , _moveSuffix: function(suffix, data, curr) {\n      var letter = suffix.charAt(0)\n        , nextSuffix = suffix.substring(1) || null\n        , opts = { $d: {} };\n      if (nextSuffix) {\n        opts.$s = nextSuffix;\n      }\n      if (typeof curr[letter] === 'undefined') {\n        curr[letter] = opts;\n      }\n      curr[letter].$d = this.options.copy(data);\n    }\n\n    /**\n    * @description Get data from a given node, either in the cache\n    *   or by parsing the subtree\n    * @param node {Object} The node to get data from\n    * @return {Array|Object} data results\n    */\n    , _getDataAtNode: function(node, word) {\n      var data;\n\n      if (this.options.enableCache) {\n        this.options.sort.call(node.$d, word);\n        data = node.$d;\n      } else {\n        data = this._getSubtree(node, word);\n      }\n      if (this.options.insertOrder) {\n        data = this._stripInsertOrder(data);\n      }\n      return data ? this.options.copy(data) : undefined;\n    }\n\n    /**\n    * @description Remove the outer data later that stores insert order\n    * @param data {Object} The data with insert order object wrapper\n    * @return {Array} data results without insert order wrapper\n    */\n    , _stripInsertOrder: function(data) {\n      if (typeof data == 'undefined') {\n        return;\n      }\n      var temp = [];\n      for (var i = 0, ii = data.length; i < ii; i++) {\n        temp.push(data[i].d);\n      }\n      return temp;\n    }\n\n    /**\n    * @description Get the subtree data of a trie traversing depth first\n    * @param curr {Object} current node in the trie to get data under\n    * @return {Object} data from the subtree\n    */\n    , _getSubtree: function(curr, word) {\n      var res\n        , nodeArray = [curr]\n        , node;\n      while (node = nodeArray.pop()) {\n        for (var newNode in node) {\n          if (node.hasOwnProperty(newNode)) {\n            if (newNode == '$d') {\n              if (typeof res == 'undefined') {\n                res = [];\n              }\n              res = this.options.merge.call(this, res, node.$d, word);\n            } else if (newNode != '$s') {\n              nodeArray.push(node[newNode]);\n            }\n          }\n        }\n      }\n      return res;\n    }\n\n    /*-------------------------------------------------------------------------\n    * Public Functions\n    -------------------------------------------------------------------------*/\n\n    /**\n    * @description Adds a word into the trie\n    * @param word {String} word to add\n    * @param data {Object} data to store under given term\n    */\n    , add: function(word, data) {\n      if (typeof word != 'string') { return false; }\n      if (arguments.length == 1) { data = word; }\n      word = word.toLowerCase();\n\n      var curr = this.root;\n\n      for (var i = 0, ii = word.length; i < ii; i++) {\n        var letter = word.charAt(i);\n        // No letter at this level\n        if (!curr[letter]) {\n          // Current level has a suffix already so push suffix lower in trie\n          if (curr.$s) {\n            if (curr.$s == word.substring(i)) {\n              // special case where word exists already, so we avoid breaking\n              // up the substring and store both at the top level\n              if (!this._addCacheData(curr, data)) {\n                curr.$d = this.options.insert.call(this, curr.$d, data);\n                this.options.sort.call(curr.$d);\n              }\n              break;\n            }\n            this._moveSuffix(curr.$s, curr.$d, curr);\n            delete curr.$s;\n            if (this.options.enableCache === false) {\n              delete curr.$d;\n            }\n          }\n          // Current level has no sub letter after building suffix\n          if (!curr[letter]) {\n            this._addSuffix(word.substring(i), data, curr);\n            this._addCacheData(curr, data);\n            break;\n          }\n          // add to the cache at the current node level in the trie\n          this._addCacheData(curr, data);\n          // if its the end of a word push possible suffixes at this node down\n          // and add data to cache at the words end\n          if (i == ii - 1) {\n            if (curr[letter].$s) {\n              this._moveSuffix(curr[letter].$s, curr[letter].$d, curr[letter]);\n              delete curr[letter].$s;\n              if (this.options.enableCache === false) {\n                delete curr[letter].$d;\n              }\n              // insert new data at current end of word node level\n              this._addSuffix(letter, data, curr);\n            } else {\n              // either add to cache or just add the data at end of word node\n              if (!this._addCacheData(curr[letter], data)) {\n                this._addSuffix(letter, data, curr);\n              }\n            }\n          }\n          curr = curr[letter];\n        }\n        // There is a letter and we are at the end of the word\n        else if (i == ii - 1) {\n          this._addCacheData(curr, data);\n          // either add to cache at the end of the word or just add the data\n          if (!this._addCacheData(curr[letter], data)) {\n            this._addSuffix(letter, data, curr);\n          }\n        }\n        // There is a letter so traverse lower into the trie\n        else {\n          this._addCacheData(curr, data);\n          curr = curr[letter];\n        }\n      }\n    }\n\n    /**\n    * @description remove a word from the trie if there is no caching\n    * @param word {String} word to remove from the trie\n    */\n    , remove: function(word) {\n      if (typeof word !== 'string' || word === '' || this.options.enableCache){\n        return;\n      }\n      word = word.toLowerCase();\n      var letter\n        , i\n        , ii\n        , curr = this.root\n        , prev\n        , prevLetter\n        , data\n        , count = 0;\n\n      for (i = 0, ii = word.length; i < ii; i++) {\n        letter = word.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s === word.substring(i)) {\n            break; // word is at this leaf node\n          } else {\n            return; // word not in the trie\n          }\n        } else {\n          prev = curr;\n          prevLetter = letter;\n          curr = curr[letter]\n        }\n      }\n      data = this.options.copy(curr.$d);\n      if (this.options.insertOrder) {\n        data = this._stripInsertOrder(data);\n      }\n      delete curr.$d;\n      delete curr.$s;\n      // enumerate all child nodes\n      for (var node in curr) {\n        if (curr.hasOwnProperty(node)) {\n          count++;\n        }\n      }\n      if (!count) {\n        delete prev[prevLetter]; // nothing left at this level so remove it\n      }\n      return data;\n    }\n\n    /**\n    * @description see if a word has been added to the trie\n    * @param word {String} word to search for\n    * @return {Boolean} whether word exists or not\n    */\n    , contains: function(word) {\n      if (typeof word !== 'string' || word == '') { return false; }\n      word = word.toLowerCase();\n\n      var curr = this.root;\n      for (var i = 0, ii = word.length; i < ii; i++) {\n        var letter = word.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s === word.substring(i)) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          curr = curr[letter];\n        }\n      }\n      return curr.$d && (typeof curr.$s === 'undefined') ? true : false;\n    }\n\n    /**\n    * @description Get the data for a given prefix of a word\n    * @param prefix {String} string of the prefix of a word\n    * @return {Object} data for the given prefix\n    */\n    , find: function(prefix) {\n      if (typeof prefix !== 'string') { return undefined; }\n      if (prefix == '' && !this.options.returnRoot) { return undefined; }\n      prefix = prefix.toLowerCase();\n\n      var curr = this.root;\n      for (var i = 0, ii = prefix.length; i < ii; i++) {\n        var letter = prefix.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s.indexOf(prefix.substring(i)) == 0) {\n            return this._getDataAtNode(curr, prefix);\n          } else {\n            return undefined;\n          }\n        } else {\n          curr = curr[letter];\n        }\n      }\n      return this._getDataAtNode(curr, prefix);\n    }\n  };\n\n  //Export to CommonJS/Node format\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = Triejs;\n    }\n    exports.Triejs = Triejs;\n  } else if (typeof define === 'function' && define.amd) {\n    define('triejs', function() {\n      return Triejs;\n    });\n  } else {\n    // no exports so attach to global\n    this['Triejs'] = Triejs;\n  }\n})(this);","<template>\r\n  <input type=\"text\" v-on:keydown=\"handleKey\" v-bind:value=\"value\"\r\n         v-on:input=\"updateValue($event.target.value)\" />\r\n</template>\r\n\r\n<script>\r\nimport TrieJS from \"triejs\";\r\n\r\nexport default {\r\n  name: \"tab-complete-input\",\r\n  data() {\r\n    return {\r\n      trie: {},\r\n      position: 0,\r\n      wordPos: 0,\r\n      index: 0,\r\n      words: [],\r\n      word: \"\",\r\n      dynamicData: false,\r\n      possible: false,\r\n      saved: false\r\n    };\r\n  },\r\n  created: function() {\r\n    this.dynamicData = this.dataSource instanceof Function;\r\n\r\n    if (!this.dynamicData) {\r\n      this.setData(this.dataSource);\r\n    }\r\n  },\r\n  props: {\r\n    dataSource: {\r\n      default: [],\r\n    },\r\n    format: {\r\n      default: function (val, prev, pos) { return {word: val, prev: prev } },\r\n      type: Function\r\n    }, \r\n    value: {\r\n      default: \"\", \r\n      type: String\r\n    }\r\n  },\r\n  methods: {\r\n    setData: function (array) {\r\n      this.trie = new TrieJS();\r\n      array.forEach(element => {\r\n        this.trie.add(element);\r\n      });\r\n    },\r\n    handleKey: async function(e) {\r\n      if (e.keyCode === 9) {\r\n        if (!this.saved) {\r\n          this.position = this.getCursorPos();\r\n          const newValue = this.value.slice(0, this.position) + \" \" + this.value.slice(this.position);\r\n          \r\n          this.words = newValue.split(\" \");\r\n          var lcount = 0;\r\n          for (var i = 0; i < this.words.length; i++) {\r\n            var w = this.words[i];\r\n            lcount += w.length + 1;\r\n            if (lcount >= this.position) {\r\n              this.word = this.words[i];\r\n              this.wordPos = i;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (this.word != \"\") {\r\n            e.preventDefault();\r\n          }\r\n\r\n          if (this.dynamicData) {\r\n            let data = this.dataSource(this.word, this.wordPos);\r\n            var array = await data;\r\n            this.setData(array);\r\n          }\r\n\r\n          this.saved = true;\r\n          this.possible = this.trie.find(this.word);\r\n        } else {\r\n          this.index++;\r\n        }\r\n\r\n        if (this.possible && this.index >= this.possible.length) {\r\n          this.index = 0;\r\n        }\r\n\r\n        if (this.possible) {\r\n          e.preventDefault();\r\n          let dupe = this.words;\r\n          let completion = this.possible[this.index];\r\n          let prev = \"\";\r\n\r\n          if (dupe.length > 1) {\r\n            prev = dupe[this.wordPos - 1];\r\n          }\r\n\r\n          let res = this.format(completion, prev, this.wordPos);\r\n          dupe[this.wordPos] = res.word;\r\n          if (res.prev) dupe[this.wordPos - 1] = res.prev;\r\n\r\n          let newPos = this.words.slice(0, this.wordPos + 1).join(\" \").length;\r\n          this.value = dupe.join(\" \");\r\n          this.value = this.value.slice(0, newPos) + this.value.slice(newPos + 1)\r\n          this.updateValue(this.value);\r\n          this.selectRange(newPos, newPos);\r\n        }\r\n      } else {\r\n        this.saved = false;\r\n        this.index = 0;\r\n      }\r\n    },\r\n\r\n    updateValue: function (value) {\r\n      this.$emit('input', value)\r\n    }, \r\n\r\n    selectRange: function (start, end) {\r\n      this.$el.focus();\r\n      this.$el.setSelectionRange(start, end);\r\n    },\r\n\r\n    getCursorPos: function() {\r\n      return this.$el.selectionStart;\r\n    }\r\n  }\r\n};\r\n</script>\r\n"]}