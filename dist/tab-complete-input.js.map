{"version":3,"file":"tab-complete-input.js","sources":["../src/lib/trie.js","../src/tab-complete-input.js"],"sourcesContent":["/**\n* Copyright (C) 2012 Paul Thurlow\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy \n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in\n* all copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\n/**\n* @decription Trie class for saving data by keywords accessible through\n*   word prefixes\n* @class\n* @version 0.1.5\n*/\nclass Triejs {\n  constructor(opts) {\n\n    /**\n    * @private\n    * @description Options for trie implementation\n    * @type {Object}\n    */\n    this.options = {\n    \n      /**\n      * @description Maximum number of items to cache per node\n      * @type {Number}\n      */\n      maxCache: 10\n\n      /**\n      * @description Whether to handle caching on node levels\n      * @type {Boolean}\n      */\n      , enableCache: true\n\n      /**\n      * @description Maintain insert ordering when adding to non cached trie\n      * @type {Boolean}\n      */\n      , insertOrder: false\n\n      /**\n      * @description Return responses from root when requests is empty\n      * @type {Boolean}\n      */\n      , returnRoot: false\n\n      /**\n      * @description Insert function for adding new items to cache\n      * @type {Function}\n      */\n      , insert: null\n\n      /**\n      * @description Sorting function for sorting items to cache\n      * @type {Function}\n      */\n      , sort: null\n\n      /**\n      * @description Clip function for removing old items from cache\n      * @type {Function}\n      */\n      , clip: null\n\n      /**\n      * @description copy function for copying data between nodes\n      * @type {Function}\n      */\n      , copy: null\n\n      /**\n      * @description Merge function to merge two data sets together\n      * @type {Function}\n      */\n      , merge: null\n    };\n\n    /**\n    * @private\n    * @description trie object\n    * @type {Object}\n    */\n    this.root = {};\n\n    /**\n    * @private\n    * @description insert order index\n    * @type {Number}\n    */\n    this.index = 0;\n\n    // mixin optional override options\n    for (const key in opts) {\n      if (opts.hasOwnProperty(key)) {\n        this.options[key] = opts[key];\n      }\n    };\n\n    if (typeof this.options.insert != 'function') {\n      this.options.insert = function(target, data) {\n        // if maintaining insert ordering add a order index on insert\n        if (this.options.insertOrder \n          && typeof data.d === 'undefined' \n          && typeof data.o === 'undefined') {\n          data = { d: data, o: this.index++ };\n        }\n        if (target && target.length) {\n          target.push(data);\n        } else {\n          target = [data];\n        }\n        return target;\n      };\n    }\n    if (typeof this.options.sort != 'function') {\n      if (!this.options.insertOrder) {\n        this.options.sort = function() {\n          this.sort();\n        };\n      } else if (this.options.insertOrder) {\n        this.options.sort = function() {\n          this.sort((a, b) => a.o - b.o);\n        }\n      }\n    }\n    if (typeof this.options.clip != 'function') {\n      this.options.clip = function(max) {\n        if (this.length > max) {\n          this.splice(max, this.length - max);\n        }\n      };\n    }\n    if (typeof this.options.copy != 'function') {\n      this.options.copy = data => data.slice(0)\n    }\n    if (typeof this.options.merge != 'function') {\n      this.options.merge = function(target, data, word) {\n        for (let i = 0, ii = data.length; i < ii; i++) {\n          target = this.options.insert.call(this, target, data[i]);\n          this.options.sort.call(target, word);\n          this.options.clip.call(target, this.options.maxCache);\n        }\n        return target;\n      }\n    }\n  }\n\n  /*-------------------------------------------------------------------------\n  * Private Functions\n  -------------------------------------------------------------------------*/\n\n  /**\n  * @description Add data to the current nodes cache\n  * @param curr {Object} current node in trie\n  * @param data {Object} Data to add to the cache\n  * @private\n  */\n  _addCacheData(curr, data) {\n    if ((this.root === curr && !this.options.returnRoot) \n      || this.options.enableCache === false) {\n      return false;\n    }\n    if (!curr.$d) {\n      curr.$d = {};\n    }\n    curr.$d = this.options.insert.call(this, curr.$d, data);\n    this.options.sort.call(curr.$d);\n    this.options.clip.call(curr.$d, this.options.maxCache);\n    return true;\n  }\n\n  /**\n  * @description Adds the remainder of a word to a subtree\n  * @param suffix {String} the remainder of a word\n  * @param data {Object} data to add at suffix\n  * @param curr {Object} current node in the trie\n  * @private\n  */\n  _addSuffix(suffix, data, curr) {\n    const letter = suffix.charAt(0);\n    const nextSuffix = suffix.substring(1) || null;\n    const opts = { $d: {} };\n    if (nextSuffix) {\n      opts.$s = nextSuffix;\n    }\n    if (typeof curr[letter] === 'undefined') {\n      curr[letter] = opts;\n    } else if (typeof curr[letter].$d === 'undefined') {\n      curr[letter].$d = {};\n      if (nextSuffix && typeof curr[letter].$s === 'undefined') {\n        curr[letter].$s = nextSuffix;\n      }\n    }\n    curr[letter].$d = this.options.insert.call(this, curr[letter].$d, data);\n    this.options.sort.call(curr[letter].$d);\n  }\n\n  /**\n  * @description Move data from current location to new suffix position\n  * @param suffix {String} the remainder of a word\n  * @param data {Object} data currently stored to be moved to suffix ending\n  * @param curr {Object} current node in the trie\n  * @private\n  */\n  _moveSuffix(suffix, data, curr) {\n    const letter = suffix.charAt(0);\n    const nextSuffix = suffix.substring(1) || null;\n    const opts = { $d: {} };\n    if (nextSuffix) {\n      opts.$s = nextSuffix;\n    }\n    if (typeof curr[letter] === 'undefined') {\n      curr[letter] = opts;\n    }\n    curr[letter].$d = this.options.copy(data);\n  }\n\n  /**\n  * @description Get data from a given node, either in the cache\n  *   or by parsing the subtree\n  * @param node {Object} The node to get data from\n  * @return {Array|Object} data results\n  */\n  _getDataAtNode(node, word) {\n      let data;\n\n      if (this.options.enableCache) {\n        this.options.sort.call(node.$d, word);\n        data = node.$d;\n      } else {\n        data = this._getSubtree(node, word);\n      }\n      if (this.options.insertOrder) {\n        data = this._stripInsertOrder(data);\n      }\n      return data ? this.options.copy(data) : undefined;\n    }\n\n  /**\n  * @description Remove the outer data later that stores insert order\n  * @param data {Object} The data with insert order object wrapper\n  * @return {Array} data results without insert order wrapper\n  */\n  _stripInsertOrder(data) {\n      if (typeof data == 'undefined') {\n        return;\n      }\n      const temp = [];\n      for (let i = 0, ii = data.length; i < ii; i++) {\n        temp.push(data[i].d);\n      }\n      return temp;\n    }\n\n  /**\n  * @description Get the subtree data of a trie traversing depth first\n  * @param curr {Object} current node in the trie to get data under\n  * @return {Object} data from the subtree\n  */\n  _getSubtree(curr, word) {\n    let res;\n    const nodeArray = [curr];\n    let node;\n    while (node = nodeArray.pop()) {\n      for (const newNode in node) {\n        if (node.hasOwnProperty(newNode)) {\n          if (newNode == '$d') {\n            if (typeof res == 'undefined') {\n              res = [];\n            }\n            res = this.options.merge.call(this, res, node.$d, word);\n          } else if (newNode != '$s') {\n            nodeArray.push(node[newNode]);\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  /*-------------------------------------------------------------------------\n  * Public Functions\n  -------------------------------------------------------------------------*/\n\n  /**\n  * @description Adds a word into the trie\n  * @param word {String} word to add\n  * @param data {Object} data to store under given term\n  */\n  add(word, data) {\n      if (typeof word != 'string') { return false; }\n      if (arguments.length == 1) { data = word; }\n      word = word.toLowerCase();\n\n      let curr = this.root;\n\n      for (let i = 0, ii = word.length; i < ii; i++) {\n        const letter = word.charAt(i);\n        // No letter at this level\n        if (!curr[letter]) {\n          // Current level has a suffix already so push suffix lower in trie\n          if (curr.$s) {\n            if (curr.$s == word.substring(i)) {\n              // special case where word exists already, so we avoid breaking\n              // up the substring and store both at the top level\n              if (!this._addCacheData(curr, data)) {\n                curr.$d = this.options.insert.call(this, curr.$d, data);\n                this.options.sort.call(curr.$d);\n              }\n              break;\n            }\n            this._moveSuffix(curr.$s, curr.$d, curr);\n            delete curr.$s;\n            if (this.options.enableCache === false) {\n              delete curr.$d;\n            }\n          }\n          // Current level has no sub letter after building suffix\n          if (!curr[letter]) {\n            this._addSuffix(word.substring(i), data, curr);\n            this._addCacheData(curr, data);\n            break;\n          }\n          // add to the cache at the current node level in the trie\n          this._addCacheData(curr, data);\n          // if its the end of a word push possible suffixes at this node down\n          // and add data to cache at the words end\n          if (i == ii - 1) {\n            if (curr[letter].$s) {\n              this._moveSuffix(curr[letter].$s, curr[letter].$d, curr[letter]);\n              delete curr[letter].$s;\n              if (this.options.enableCache === false) {\n                delete curr[letter].$d;\n              }\n              // insert new data at current end of word node level\n              this._addSuffix(letter, data, curr);\n            } else {\n              // either add to cache or just add the data at end of word node\n              if (!this._addCacheData(curr[letter], data)) {\n                this._addSuffix(letter, data, curr);\n              }\n            }\n          }\n          curr = curr[letter];\n        }\n        // There is a letter and we are at the end of the word\n        else if (i == ii - 1) {\n          this._addCacheData(curr, data);\n          // either add to cache at the end of the word or just add the data\n          if (!this._addCacheData(curr[letter], data)) {\n            this._addSuffix(letter, data, curr);\n          }\n        }\n        // There is a letter so traverse lower into the trie\n        else {\n          this._addCacheData(curr, data);\n          curr = curr[letter];\n        }\n      }\n    }\n\n  /**\n  * @description remove a word from the trie if there is no caching\n  * @param word {String} word to remove from the trie\n  */\n  remove(word) {\n    if (typeof word !== 'string' || word === '' || this.options.enableCache){\n      return;\n    }\n    word = word.toLowerCase();\n    let letter;\n    let i;\n    let ii;\n    let curr = this.root;\n    let prev;\n    let prevLetter;\n    let data;\n    let count = 0;\n\n    for (i = 0, ii = word.length; i < ii; i++) {\n      letter = word.charAt(i);\n      if (!curr[letter]) {\n        if (curr.$s && curr.$s === word.substring(i)) {\n          break; // word is at this leaf node\n        } else {\n          return; // word not in the trie\n        }\n      } else {\n        prev = curr;\n        prevLetter = letter;\n        curr = curr[letter]\n      }\n    }\n    data = this.options.copy(curr.$d);\n    if (this.options.insertOrder) {\n      data = this._stripInsertOrder(data);\n    }\n    delete curr.$d;\n    delete curr.$s;\n    // enumerate all child nodes\n    for (const node in curr) {\n      if (curr.hasOwnProperty(node)) {\n        count++;\n      }\n    }\n    if (!count) {\n      delete prev[prevLetter]; // nothing left at this level so remove it\n    }\n    return data;\n  }\n\n  /**\n  * @description see if a word has been added to the trie\n  * @param word {String} word to search for\n  * @return {Boolean} whether word exists or not\n  */\n  contains(word) {\n      if (typeof word !== 'string' || word == '') { return false; }\n      word = word.toLowerCase();\n\n      let curr = this.root;\n      for (let i = 0, ii = word.length; i < ii; i++) {\n        const letter = word.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s === word.substring(i)) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          curr = curr[letter];\n        }\n      }\n      return curr.$d && (typeof curr.$s === 'undefined') ? true : false;\n    }\n\n  /**\n  * @description Get the data for a given prefix of a word\n  * @param prefix {String} string of the prefix of a word\n  * @return {Object} data for the given prefix\n  */\n  find(prefix) {\n      if (typeof prefix !== 'string') { return undefined; }\n      if (prefix == '' && !this.options.returnRoot) { return undefined; }\n      prefix = prefix.toLowerCase();\n\n      let curr = this.root;\n      for (let i = 0, ii = prefix.length; i < ii; i++) {\n        const letter = prefix.charAt(i);\n        if (!curr[letter]) {\n          if (curr.$s && curr.$s.indexOf(prefix.substring(i)) == 0) {\n            return this._getDataAtNode(curr, prefix);\n          } else {\n            return undefined;\n          }\n        } else {\n          curr = curr[letter];\n        }\n      }\n      return this._getDataAtNode(curr, prefix);\n    }\n}\n\nexport default Triejs","import TrieJS from \"./lib/trie\";\n\nexport default {\n  name: \"tab-complete-input\",\n  data () {\n    return {\n      trie: {},\n      position: 0,\n      wordPos: 0,\n      index: 0,\n      words: [],\n      word: \"\",\n      dynamicData: false,\n      possible: false,\n      saved: false,\n      localValue: this.value\n    };\n  },\n  render (h) {\n    var self = this\n    return h('input', {\n      ref: 'input',\n      attrs: {\n        ...self.$props\n      },\n      domProps: {\n        value: self.value\n      },\n      directives: [\n        { name: 'model', rawName: 'v-model', value: self.localValue, expression: 'value' }\n      ],\n      on: {\n        ...self.$listeners,\n        keydown: self.$listeners.keydown ? [ self.tabComplete, self.$listeners.keydown ] : self.tabComplete,\n        input (event) {\n          self.localValue = event.target.value\n          self.$emit('input', event.target.value)\n        }\n      }\n    })\n  },\n  created () {\n    this.dynamicData = this.dataSource instanceof Function;\n\n    if (!this.dynamicData) {\n      this.setData(this.dataSource);\n    }\n  },\n  props: {\n    dataSource: {\n      default: () => [],\n    },\n    format: {\n      default: (val, prev, pos) => ({ word: val, prev: prev }),\n      type: Function\n    }, \n    value: {\n      default: \"\", \n      type: String\n    }\n  },\n  watch: {\n    // whenever question changes, this function will run\n    dataSource (data) {\n      this.dynamicData = data instanceof Function;\n\n      if (!this.dynamicData) {\n        this.setData(data);\n      }\n    }\n  },\n  methods: {\n    setData (array) {\n      this.trie = new TrieJS();\n      array.forEach(element => {\n        this.trie.add(element);\n      });\n    },\n\n    async tabComplete (e) {\n      if (e && e.keyCode !== 9) {\n        this.saved = false;\n        this.index = 0;\n\n        return\n      }\n      if (!this.saved) {\n        this.position = this.getCursorPos();\n        const newValue = this.localValue.slice(0, this.position) + \" \" + this.localValue.slice(this.position);\n        \n        this.words = newValue.split(\" \");\n        var lcount = 0;\n        for (var i = 0; i < this.words.length; i++) {\n          var w = this.words[i];\n          lcount += w.length + 1;\n          if (lcount >= this.position) {\n            this.word = this.words[i];\n            this.wordPos = i;\n            break;\n          }\n        }\n\n        if (this.word != \"\" && e) {\n          e.preventDefault();\n        }\n\n        if (this.dynamicData) {\n          let data = this.dataSource(this.word, this.wordPos);\n          var array = await data;\n          this.setData(array);\n        }\n\n        this.saved = true;\n        this.possible = this.trie.find(this.word);\n      } else {\n        this.index++;\n      }\n\n      if (this.possible && this.index >= this.possible.length) {\n        this.index = 0;\n      }\n\n      if (this.possible) {\n        if (e) e.preventDefault();\n        let dupe = this.words;\n        let completion = this.possible[this.index];\n        let prev = \"\";\n\n        if (dupe.length > 1) {\n          prev = dupe[this.wordPos - 1];\n        }\n\n        let res = this.format(completion, prev, this.wordPos);\n        dupe[this.wordPos] = res.word;\n        if (res.prev) dupe[this.wordPos - 1] = res.prev;\n\n        let newPos = this.words.slice(0, this.wordPos + 1).join(\" \").length;\n        this.localValue = dupe.join(\" \");\n        this.localValue = this.localValue.slice(0, newPos) + this.localValue.slice(newPos + 1)\n        this.updateValue(this.localValue);\n        this.selectRange(newPos, newPos);\n      }\n    },\n\n    updateValue (value) {\n      this.localValue = value\n      this.$emit('input', value)\n    }, \n\n    selectRange (start, end) {\n      this.$el.focus();\n      this.$el.setSelectionRange(start, end);\n    },\n\n    getCursorPos () {\n      return this.$el.selectionStart;\n    }\n  }\n}\n"],"names":["Triejs","constructor","opts","const","key","options","root","index","hasOwnProperty","this","insert","target","data","insertOrder","d","o","length","push","sort","a","b","clip","max","splice","copy","slice","merge","word","let","i","ii","call","maxCache","_addCacheData","curr","returnRoot","enableCache","$d","_addSuffix","suffix","letter","charAt","nextSuffix","substring","$s","_moveSuffix","_getDataAtNode","node","_getSubtree","_stripInsertOrder","undefined","temp","res","nodeArray","pop","newNode","add","arguments","toLowerCase","remove","prev","prevLetter","count","contains","find","prefix","indexOf","name","trie","position","wordPos","words","dynamicData","possible","saved","localValue","value","render","h","self","ref","attrs","Object","$props","domProps","directives","rawName","expression","on","$listeners","keydown","tabComplete","input","event","$emit","created","dataSource","Function","setData","props","default","format","val","pos","type","String","watch","methods","array","TrieJS","forEach","element","e","_this","preventDefault","dupe","newPos","join","updateValue","selectRange","keyCode","getCursorPos","newValue","split","lcount","start","end","$el","focus","setSelectionRange","selectionStart"],"mappings":"AA4BA,IAAMA,EACJC,SAAYC,OA+ELC,IAAMC,UAxENC,QAAU,UAMH,gBAMK,eAMA,cAMD,SAMJ,UAMF,UAMA,UAMA,WAMC,WAQNC,KAAO,QAOPC,MAAQ,EAGKL,EACZA,EAAKM,eAAeJ,UACjBC,QAAQD,GAAOF,EAAKE,IAIK,mBAAvBK,KAAKJ,QAAQK,cACjBL,QAAQK,OAAS,SAASC,EAAQC,UAEjCH,KAAKJ,QAAQQ,kBACM,IAAXD,EAAKE,QACM,IAAXF,EAAKG,IACfH,EAAO,GAAKA,EAAMG,EAAGN,KAAKF,UAExBI,GAAUA,EAAOK,OACnBL,EAAOM,KAAKL,GAEZD,EAAS,CAACC,GAELD,IAGqB,mBAArBF,KAAKJ,QAAQa,OACjBT,KAAKJ,QAAQQ,YAIPJ,KAAKJ,QAAQQ,mBACjBR,QAAQa,KAAO,gBACbA,cAAMC,EAAGC,UAAMD,EAAEJ,EAAIK,EAAEL,WALzBV,QAAQa,KAAO,gBACbA,SAQqB,mBAArBT,KAAKJ,QAAQgB,YACjBhB,QAAQgB,KAAO,SAASC,GACvBb,KAAKO,OAASM,QACXC,OAAOD,EAAKb,KAAKO,OAASM,KAIL,mBAArBb,KAAKJ,QAAQmB,YACjBnB,QAAQmB,cAAOZ,UAAQA,EAAKa,MAAM,KAER,mBAAtBhB,KAAKJ,QAAQqB,aACjBrB,QAAQqB,MAAQ,SAASf,EAAQC,EAAMe,OACrCC,IAAIC,EAAI,EAAGC,EAAKlB,EAAKI,OAAQa,EAAIC,EAAID,IACxClB,EAASF,KAAKJ,QAAQK,OAAOqB,KAAKtB,KAAME,EAAQC,EAAKiB,SAChDxB,QAAQa,KAAKa,KAAKpB,EAAQgB,QAC1BtB,QAAQgB,KAAKU,KAAKpB,EAAQF,KAAKJ,QAAQ2B,iBAEvCrB,KAebsB,YAAAA,uBAAcC,EAAMtB,WACbH,KAAKH,OAAS4B,IAASzB,KAAKJ,QAAQ8B,aACP,IAA7B1B,KAAKJ,QAAQ+B,eAGbF,EAAKG,KACRH,EAAKG,GAAK,MAEPA,GAAK5B,KAAKJ,QAAQK,OAAOqB,KAAKtB,KAAMyB,EAAKG,GAAIzB,QAC7CP,QAAQa,KAAKa,KAAKG,EAAKG,SACvBhC,QAAQgB,KAAKU,KAAKG,EAAKG,GAAI5B,KAAKJ,QAAQ2B,WACtC,IAUTM,YAAAA,oBAAWC,EAAQ3B,EAAMsB,OACjBM,EAASD,EAAOE,OAAO,GACvBC,EAAaH,EAAOI,UAAU,IAAM,KACpCzC,EAAO,IAAM,IACfwC,IACFxC,EAAK0C,GAAKF,QAEgB,IAAjBR,EAAKM,GACdN,EAAKM,GAAUtC,OACqB,IAApBgC,EAAKM,GAAQH,OACxBG,GAAQH,GAAK,GACdK,QAAyC,IAApBR,EAAKM,GAAQI,OAC/BJ,GAAQI,GAAKF,MAGjBF,GAAQH,GAAK5B,KAAKJ,QAAQK,OAAOqB,KAAKtB,KAAMyB,EAAKM,GAAQH,GAAIzB,QAC7DP,QAAQa,KAAKa,KAAKG,EAAKM,GAAQH,KAUtCQ,YAAAA,qBAAYN,EAAQ3B,EAAMsB,OAClBM,EAASD,EAAOE,OAAO,GACvBC,EAAaH,EAAOI,UAAU,IAAM,KACpCzC,EAAO,IAAM,IACfwC,IACFxC,EAAK0C,GAAKF,QAEgB,IAAjBR,EAAKM,KACdN,EAAKM,GAAUtC,GAEjBgC,EAAKM,GAAQH,GAAK5B,KAAKJ,QAAQmB,KAAKZ,IAStCkC,YAAAA,wBAAeC,EAAMpB,OACbf,SAEAH,KAAKJ,QAAQ+B,kBACV/B,QAAQa,KAAKa,KAAKgB,EAAKV,GAAIV,GAChCf,EAAOmC,EAAKV,MAEL5B,KAAKuC,YAAYD,EAAMpB,GAE5BlB,KAAKJ,QAAQQ,gBACRJ,KAAKwC,kBAAkBrC,IAEzBA,EAAOH,KAAKJ,QAAQmB,KAAKZ,QAAQsC,GAQ5CD,YAAAA,2BAAkBrC,WACK,IAARA,WAGLuC,EAAO,GACJtB,EAAI,EAAGC,EAAKlB,EAAKI,OAAQa,EAAIC,EAAID,MACnCZ,KAAKL,EAAKiB,GAAGf,UAEbqC,IAQXH,YAAAA,qBAAYd,EAAMP,WACZyB,EAEAL,EADEM,EAAY,CAACnB,GAEZa,EAAOM,EAAUC,WACjBnD,IAAMoD,KAAWR,EAChBA,EAAKvC,eAAe+C,KACP,MAAXA,QACgB,IAAPH,MACH,MAEF3C,KAAKJ,QAAQqB,MAAMK,KAAKtB,KAAM2C,EAAKL,EAAKV,GAAIV,IAC9B,MAAX4B,KACCtC,KAAK8B,EAAKQ,YAKrBH,GAYTI,YAAAA,aAAI7B,EAAMf,MACa,iBAARe,SAA2B,EACd,GAApB8B,UAAUzC,WAAsBW,GACpCA,EAAOA,EAAK+B,sBAERxB,EAAOzB,KAAKH,KAEPuB,EAAI,EAAGC,EAAKH,EAAKX,OAAQa,EAAIC,EAAID,IAAK,KACvCW,EAASb,EAAKc,OAAOZ,MAEtBK,EAAKM,GA+CDX,GAAKC,EAAK,QACZG,cAAcC,EAAMtB,GAEpBH,KAAKwB,cAAcC,EAAKM,GAAS5B,SAC/B0B,WAAWE,EAAQ5B,EAAMsB,UAK3BD,cAAcC,EAAMtB,GACzBsB,EAAOA,EAAKM,QAzDK,IAEbN,EAAKU,GAAI,IACPV,EAAKU,IAAMjB,EAAKgB,UAAUd,GAAI,CAG3BpB,KAAKwB,cAAcC,EAAMtB,OACvByB,GAAK5B,KAAKJ,QAAQK,OAAOqB,KAAKtB,KAAMyB,EAAKG,GAAIzB,QAC7CP,QAAQa,KAAKa,KAAKG,EAAKG,gBAI3BQ,YAAYX,EAAKU,GAAIV,EAAKG,GAAIH,UAC5BA,EAAKU,IACqB,IAA7BnC,KAAKJ,QAAQ+B,oBACRF,EAAKG,OAIXH,EAAKM,GAAS,MACZF,WAAWX,EAAKgB,UAAUd,GAAIjB,EAAMsB,QACpCD,cAAcC,EAAMtB,cAItBqB,cAAcC,EAAMtB,GAGrBiB,GAAKC,EAAK,IACRI,EAAKM,GAAQI,SACVC,YAAYX,EAAKM,GAAQI,GAAIV,EAAKM,GAAQH,GAAIH,EAAKM,WACjDN,EAAKM,GAAQI,IACa,IAA7BnC,KAAKJ,QAAQ+B,oBACRF,EAAKM,GAAQH,QAGjBC,WAAWE,EAAQ5B,EAAMsB,IAGzBzB,KAAKwB,cAAcC,EAAKM,GAAS5B,SAC/B0B,WAAWE,EAAQ5B,EAAMsB,IAIpCA,EAAOA,EAAKM,MAsBpBmB,YAAAA,gBAAOhC,MACe,iBAATA,GAA8B,KAATA,IAAelB,KAAKJ,QAAQ+B,iBAIxDI,EACAX,EACAC,EAHJH,EAAOA,EAAK+B,kBAKRE,EACAC,EACAjD,EAHAsB,EAAOzB,KAAKH,KAIZwD,EAAQ,MAEPjC,EAAI,EAAGC,EAAKH,EAAKX,OAAQa,EAAIC,EAAID,IAAK,KAEpCK,IADIP,EAAKc,OAAOZ,IACF,IACbK,EAAKU,IAAMV,EAAKU,KAAOjB,EAAKgB,UAAUd,kBAMnCK,IACMM,EACbN,EAAOA,EAAKM,OAUXrC,IAAM4C,KAPXnC,EAAOH,KAAKJ,QAAQmB,KAAKU,EAAKG,IAC1B5B,KAAKJ,QAAQQ,gBACRJ,KAAKwC,kBAAkBrC,WAEzBsB,EAAKG,UACLH,EAAKU,GAEOV,EACbA,EAAK1B,eAAeuC,eAIrBe,UACIF,EAAKC,GAEPjD,IAQTmD,YAAAA,kBAASpC,MACe,iBAATA,GAA6B,IAARA,SAAqB,EACrDA,EAAOA,EAAK+B,sBAERxB,EAAOzB,KAAKH,KACPuB,EAAI,EAAGC,EAAKH,EAAKX,OAAQa,EAAIC,EAAID,IAAK,KACvCW,EAASb,EAAKc,OAAOZ,OACtBK,EAAKM,YACJN,EAAKU,IAAMV,EAAKU,KAAOjB,EAAKgB,UAAUd,IAM1CK,EAAOA,EAAKM,YAGTN,EAAKG,SAA0B,IAAZH,EAAKU,KAQnCoB,YAAAA,cAAKC,MACqB,iBAAXA,IACG,IAAVA,GAAiBxD,KAAKJ,QAAQ8B,aAClC8B,EAASA,EAAOP,sBAEZxB,EAAOzB,KAAKH,KACPuB,EAAI,EAAGC,EAAKmC,EAAOjD,OAAQa,EAAIC,EAAID,IAAK,KACzCW,EAASyB,EAAOxB,OAAOZ,OACxBK,EAAKM,UACJN,EAAKU,IAA8C,GAAxCV,EAAKU,GAAGsB,QAAQD,EAAOtB,UAAUd,IACvCpB,KAAKqC,eAAeZ,EAAM+B,UAKnC/B,EAAOA,EAAKM,UAGT/B,KAAKqC,eAAeZ,EAAM+B,KCzdvC,MAAe,CACbE,KAAM,qBACNvD,sBACS,CACLwD,KAAM,GACNC,SAAU,EACVC,QAAS,EACT/D,MAAO,EACPgE,MAAO,GACP5C,KAAM,GACN6C,aAAa,EACbC,UAAU,EACVC,OAAO,EACPC,WAAYlE,KAAKmE,QAGrBC,gBAAQC,OACFC,EAAOtE,YACJqE,EAAE,QAAS,CAChBE,IAAK,QACLC,MAAOC,iBACFH,EAAKI,QAEVC,SAAU,CACRR,MAAOG,EAAKH,OAEdS,WAAY,CACV,CAAElB,KAAM,QAASmB,QAAS,UAAWV,MAAOG,EAAKJ,WAAYY,WAAY,UAE3EC,GAAIN,iBACCH,EAAKU,YACRC,QAASX,EAAKU,WAAWC,QAAU,CAAEX,EAAKY,YAAaZ,EAAKU,WAAWC,SAAYX,EAAKY,YACxFC,eAAOC,GACLd,EAAKJ,WAAakB,EAAMlF,OAAOiE,MAC/BG,EAAKe,MAAM,QAASD,EAAMlF,OAAOiE,aAKzCmB,wBACOvB,YAAc/D,KAAKuF,sBAAsBC,SAEzCxF,KAAK+D,kBACH0B,QAAQzF,KAAKuF,aAGtBG,MAAO,CACLH,WAAY,CACVI,yBAAe,KAEjBC,OAAQ,CACND,iBAAUE,EAAK1C,EAAM2C,UAAW5E,KAAM2E,EAAK1C,KAAMA,IACjD4C,KAAMP,UAERrB,MAAO,CACLwB,QAAS,GACTI,KAAMC,SAGVC,MAAO,CAELV,oBAAYpF,QACL4D,YAAc5D,aAAgBqF,SAE9BxF,KAAK+D,kBACH0B,QAAQtF,KAInB+F,QAAS,CACPT,iBAASU,mBACFxC,KAAO,IAAIyC,EAChBD,EAAME,iBAAQC,KACP3C,KAAKZ,IAAIuD,MAIZpB,qBAAaqB,aAEfvG,qBAqCEwG,EAAKxC,UAAYwC,EAAK1G,OAAS0G,EAAKxC,SAASzD,WAC1CT,MAAQ,GAGX0G,EAAKxC,UACHuC,GAAGA,EAAEE,qBACLC,EAAOF,EAAK1C,MAEZX,EAAO,GAEPuD,EAAKnG,OAAS,IAChB4C,EAAOuD,EAAKF,EAAK3C,QAAU,QAGzBlB,EAAM6D,EAAKZ,OAPEY,EAAKxC,SAASwC,EAAK1G,OAOFqD,EAAMqD,EAAK3C,SAC7C6C,EAAKF,EAAK3C,SAAWlB,EAAIzB,KACrByB,EAAIQ,OAAMuD,EAAKF,EAAK3C,QAAU,GAAKlB,EAAIQ,UAEvCwD,EAASH,EAAK1C,MAAM9C,MAAM,EAAGwF,EAAK3C,QAAU,GAAG+C,KAAK,KAAKrG,SACxD2D,WAAawC,EAAKE,KAAK,OACvB1C,WAAasC,EAAKtC,WAAWlD,MAAM,EAAG2F,GAAUH,EAAKtC,WAAWlD,MAAM2F,EAAS,KAC/EE,YAAYL,EAAKtC,cACjB4C,YAAYH,EAAQA,OA5DvBJ,GAAmB,IAAdA,EAAEQ,iBACJ9C,OAAQ,IACRnE,MAAQ,yCAIV0G,EAAKvC,sBA0BHA,OAAQ,IACRD,SAAWwC,EAAK7C,KAAKJ,KAAKiD,EAAKtF,QA1B/B0C,SAAW4C,EAAKQ,mBACfC,EAAWT,EAAKtC,WAAWlD,MAAM,EAAGwF,EAAK5C,UAAY,IAAM4C,EAAKtC,WAAWlD,MAAMwF,EAAK5C,YAEvFE,MAAQmD,EAASC,MAAM,aACxBC,EAAS,EACJ/F,EAAI,EAAGA,EAAIoF,EAAK1C,MAAMvD,OAAQa,IAAK,KAE1C+F,GADQX,EAAK1C,MAAM1C,GACPb,OAAS,IACPiG,EAAK5C,SAAU,GACtB1C,KAAOsF,EAAK1C,MAAM1C,KAClByC,QAAUzC,SAKF,IAAboF,EAAKtF,MAAcqF,GACrBA,EAAEE,qCAGAD,EAAKzC,iBACH5D,EAAOqG,EAAKjB,WAAWiB,EAAKtF,KAAMsF,EAAK3C,gCACzB1D,iBAAdgG,KACCV,QAAQU,0CAMVrG,+FA6BT+G,qBAAa1C,QACND,WAAaC,OACbkB,MAAM,QAASlB,IAGtB2C,qBAAaM,EAAOC,QACbC,IAAIC,aACJD,IAAIE,kBAAkBJ,EAAOC,IAGpCL,+BACShH,KAAKsH,IAAIG"}