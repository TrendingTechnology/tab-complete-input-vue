{"version":3,"file":"tab-complete-input.js","sources":["../src/trie.ts","../src/tab-complete-input.ts"],"sourcesContent":["/**\r\n * Copyright (C) 2012 Paul Thurlow\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\ninterface Options {\r\n  enableCache: boolean;\r\n  insertOrder: boolean;\r\n  returnRoot: boolean;\r\n  [key: string]: any;\r\n}\r\n\r\ninterface Methods {\r\n  insert: Function;\r\n  sort: Function;\r\n  clip: Function;\r\n  copy: Function;\r\n  merge: Function;\r\n  [key: string]: any;\r\n}\r\n\r\nconst defaultOptions: Options = {\r\n  enableCache: true,\r\n  insertOrder: false,\r\n  returnRoot: false\r\n};\r\n\r\ninterface Data {\r\n  $d?: string | any;\r\n  $s?: string;\r\n  [key: string]: any;\r\n}\r\n\r\ninterface Ordered {\r\n  d?: string;\r\n  o?: number;\r\n}\r\n\r\nfunction isOrdered(data: Ordered | any): data is Ordered {\r\n  return (data as Ordered).d !== undefined && (data as Ordered).o !== undefined;\r\n}\r\n\r\n/**\r\n * @decription Trie class for saving data by keywords accessible through\r\n *   word prefixes\r\n * @class\r\n * @version 0.1.5\r\n */\r\nclass TrieJS {\r\n  private options: Options | Methods = defaultOptions;\r\n  private root: Data = {};\r\n  private index = 0;\r\n\r\n  constructor(opts?: Options) {\r\n    // mixin optional override options\r\n    for (const key in opts) {\r\n      const hasProp = Object.prototype.hasOwnProperty.call(opts, key);\r\n\r\n      if (hasProp) {\r\n        this.options[key] = opts[key];\r\n      }\r\n    }\r\n\r\n    if (typeof this.options.insert != \"function\") {\r\n      this.options.insert = (target: any[], item: string) => {\r\n        // if maintaining insert ordering add a order index on insert\r\n        let data: Ordered | string;\r\n        if (this.options.insertOrder && !isOrdered(item)) {\r\n          data = { d: item, o: this.index++ };\r\n        }\r\n        if (target && target.length) {\r\n          target.push(item);\r\n        } else {\r\n          target = [item];\r\n        }\r\n        return target;\r\n      };\r\n    }\r\n\r\n    if (typeof this.options.sort != \"function\") {\r\n      if (!this.options.insertOrder) {\r\n        this.options.sort = function(this: Data[]) {\r\n          this.sort();\r\n        };\r\n      } else if (this.options.insertOrder) {\r\n        this.options.sort = function(this: Data[]) {\r\n          this.sort((a, b) => {\r\n            if (a.o === undefined || b.o === undefined) {\r\n              return 0;\r\n            }\r\n\r\n            return a.o - b.o;\r\n          });\r\n        };\r\n      }\r\n    }\r\n\r\n    if (typeof this.options.clip != \"function\") {\r\n      this.options.clip = function(this: Data[], max: number) {\r\n        if (this.length > max) {\r\n          this.splice(max, this.length - max);\r\n        }\r\n      };\r\n    }\r\n\r\n    if (typeof this.options.copy != \"function\") {\r\n      this.options.copy = (data: any[]) => data.slice(0);\r\n    }\r\n\r\n    if (typeof this.options.merge != \"function\") {\r\n      this.options.merge = (target: Data[], data: any, word: string) => {\r\n        for (let i = 0, ii = data.length; i < ii; i++) {\r\n          target = this.options.insert.call(this, target, data[i]);\r\n          this.options.sort.call(target, word);\r\n        }\r\n        return target;\r\n      };\r\n    }\r\n  }\r\n\r\n  /*-------------------------------------------------------------------------\r\n    * Private Functions\r\n    -------------------------------------------------------------------------*/\r\n\r\n  /**\r\n   * @description Add data to the current nodes cache\r\n   * @param curr {Object} current node in trie\r\n   * @param data {Object} Data to add to the cache\r\n   * @private\r\n   */\r\n  private _addCacheData(curr: Data, data: Data) {\r\n    if (\r\n      (this.root === curr && !this.options.returnRoot) ||\r\n      this.options.enableCache === false\r\n    ) {\r\n      return false;\r\n    }\r\n    if (!curr.$d) {\r\n      curr.$d = {};\r\n    }\r\n\r\n    curr.$d = this.options.insert.call(this, curr.$d, data);\r\n    this.options.sort.call(curr.$d);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @description Adds the remainder of a word to a subtree\r\n   * @param suffix {String} the remainder of a word\r\n   * @param data {Object} data to add at suffix\r\n   * @param curr {Object} current node in the trie\r\n   * @private\r\n   */\r\n  private _addSuffix(suffix: string, data: Data, curr: Data) {\r\n    const letter = suffix.charAt(0);\r\n    const nextSuffix = suffix.substring(1) || null;\r\n    const opts: Data = { $d: {} };\r\n    if (nextSuffix) {\r\n      opts.$s = nextSuffix;\r\n    }\r\n    if (typeof curr[letter] === \"undefined\") {\r\n      curr[letter] = opts;\r\n    } else if (typeof curr[letter].$d === \"undefined\") {\r\n      curr[letter].$d = {};\r\n      if (nextSuffix && typeof curr[letter].$s === \"undefined\") {\r\n        curr[letter].$s = nextSuffix;\r\n      }\r\n    }\r\n    curr[letter].$d = this.options.insert.call(this, curr[letter].$d, data);\r\n    this.options.sort.call(curr[letter].$d);\r\n  }\r\n\r\n  /**\r\n   * @description Move data from current location to new suffix position\r\n   * @param suffix {String} the remainder of a word\r\n   * @param data {Object} data currently stored to be moved to suffix ending\r\n   * @param curr {Object} current node in the trie\r\n   * @private\r\n   */\r\n  private _moveSuffix(suffix: string, data: Data, curr: Data) {\r\n    const letter = suffix.charAt(0);\r\n    const nextSuffix = suffix.substring(1) || null;\r\n    const opts: Data = { $d: {} };\r\n    if (nextSuffix) {\r\n      opts.$s = nextSuffix;\r\n    }\r\n    if (typeof curr[letter] === \"undefined\") {\r\n      curr[letter] = opts;\r\n    }\r\n    curr[letter].$d = this.options.copy(data);\r\n  }\r\n\r\n  /**\r\n   * @description Get data from a given node, either in the cache\r\n   *   or by parsing the subtree\r\n   * @param node {Object} The node to get data from\r\n   * @return {Array|Object} data results\r\n   */\r\n  private _getDataAtNode(node: Data, word: string) {\r\n    let data;\r\n\r\n    if (this.options.enableCache) {\r\n      this.options.sort.call(node.$d, word);\r\n      data = node.$d;\r\n    } else {\r\n      data = this._getSubtree(node, word);\r\n    }\r\n    if (this.options.insertOrder) {\r\n      data = this._stripInsertOrder(data);\r\n    }\r\n    return data ? this.options.copy(data) : undefined;\r\n  }\r\n\r\n  /**\r\n   * @description Remove the outer data later that stores insert order\r\n   * @param data {Object} The data with insert order object wrapper\r\n   * @return {Array} data results without insert order wrapper\r\n   */\r\n  private _stripInsertOrder(data: Ordered[]) {\r\n    if (typeof data == \"undefined\") {\r\n      return;\r\n    }\r\n    const temp = [];\r\n    for (let i = 0, ii = data.length; i < ii; i++) {\r\n      temp.push(data[i].d);\r\n    }\r\n    return temp;\r\n  }\r\n\r\n  /**\r\n   * @description Get the subtree data of a trie traversing depth first\r\n   * @param curr {Object} current node in the trie to get data under\r\n   * @return {Object} data from the subtree\r\n   */\r\n  private _getSubtree(curr: Data, word: string) {\r\n    let res: Data = [];\r\n    const nodeArray = [curr];\r\n    let node;\r\n    while ((node = nodeArray.pop())) {\r\n      for (const newNode in node) {\r\n        const hasProp = Object.prototype.hasOwnProperty.call(node, newNode);\r\n        if (hasProp) {\r\n          if (newNode == \"$d\") {\r\n            res = this.options.merge.call(this, res, node.$d, word);\r\n          } else if (newNode != \"$s\") {\r\n            nodeArray.push(node[newNode]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /*-------------------------------------------------------------------------\r\n    * Public Functions\r\n    -------------------------------------------------------------------------*/\r\n\r\n  /**\r\n   * @description Adds a word into the trie\r\n   * @param word {String} word to add\r\n   * @param data {Object} data to store under given term\r\n   */\r\n  add(word: string, data?: any) {\r\n    if (typeof word != \"string\") {\r\n      return false;\r\n    }\r\n    if (arguments.length == 1) {\r\n      data = word;\r\n    }\r\n    word = word.toLowerCase();\r\n\r\n    let curr = this.root;\r\n\r\n    for (let i = 0, ii = word.length; i < ii; i++) {\r\n      const letter = word.charAt(i);\r\n      // No letter at this level\r\n      if (!curr[letter]) {\r\n        // Current level has a suffix already so push suffix lower in trie\r\n        if (curr.$s) {\r\n          if (curr.$s == word.substring(i)) {\r\n            // special case where word exists already, so we avoid breaking\r\n            // up the substring and store both at the top level\r\n            if (!this._addCacheData(curr, data)) {\r\n              curr.$d = this.options.insert.call(this, curr.$d, data);\r\n              this.options.sort.call(curr.$d);\r\n            }\r\n            break;\r\n          }\r\n          this._moveSuffix(curr.$s, curr.$d, curr);\r\n          delete curr.$s;\r\n          if (this.options.enableCache === false) {\r\n            delete curr.$d;\r\n          }\r\n        }\r\n        // Current level has no sub letter after building suffix\r\n        if (!curr[letter]) {\r\n          this._addSuffix(word.substring(i), data, curr);\r\n          this._addCacheData(curr, data);\r\n          break;\r\n        }\r\n        // add to the cache at the current node level in the trie\r\n        this._addCacheData(curr, data);\r\n        // if its the end of a word push possible suffixes at this node down\r\n        // and add data to cache at the words end\r\n        if (i == ii - 1) {\r\n          if (curr[letter].$s) {\r\n            this._moveSuffix(curr[letter].$s, curr[letter].$d, curr[letter]);\r\n            delete curr[letter].$s;\r\n            if (this.options.enableCache === false) {\r\n              delete curr[letter].$d;\r\n            }\r\n            // insert new data at current end of word node level\r\n            this._addSuffix(letter, data, curr);\r\n          } else {\r\n            // either add to cache or just add the data at end of word node\r\n            if (!this._addCacheData(curr[letter], data)) {\r\n              this._addSuffix(letter, data, curr);\r\n            }\r\n          }\r\n        }\r\n        curr = curr[letter];\r\n      }\r\n      // There is a letter and we are at the end of the word\r\n      else if (i == ii - 1) {\r\n        this._addCacheData(curr, data);\r\n        // either add to cache at the end of the word or just add the data\r\n        if (!this._addCacheData(curr[letter], data)) {\r\n          this._addSuffix(letter, data, curr);\r\n        }\r\n      }\r\n      // There is a letter so traverse lower into the trie\r\n      else {\r\n        this._addCacheData(curr, data);\r\n        curr = curr[letter];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description see if a word has been added to the trie\r\n   * @param word {String} word to search for\r\n   * @return {Boolean} whether word exists or not\r\n   */\r\n  contains(word: string) {\r\n    if (typeof word !== \"string\" || word == \"\") {\r\n      return false;\r\n    }\r\n    word = word.toLowerCase();\r\n\r\n    let curr = this.root;\r\n    for (let i = 0, ii = word.length; i < ii; i++) {\r\n      const letter = word.charAt(i);\r\n      if (!curr[letter]) {\r\n        if (curr.$s && curr.$s === word.substring(i)) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      } else {\r\n        curr = curr[letter];\r\n      }\r\n    }\r\n    return curr.$d && typeof curr.$s === \"undefined\" ? true : false;\r\n  }\r\n\r\n  /**\r\n   * @description Get the data for a given prefix of a word\r\n   * @param prefix {String} string of the prefix of a word\r\n   * @return {Array|Object} data for the given prefix\r\n   */\r\n  find(prefix: string) {\r\n    if (typeof prefix !== \"string\") {\r\n      return undefined;\r\n    }\r\n    if (prefix == \"\" && !this.options.returnRoot) {\r\n      return undefined;\r\n    }\r\n    prefix = prefix.toLowerCase();\r\n\r\n    let curr = this.root;\r\n    for (let i = 0, ii = prefix.length; i < ii; i++) {\r\n      const letter = prefix.charAt(i);\r\n      if (!curr[letter]) {\r\n        if (curr.$s && curr.$s.indexOf(prefix.substring(i)) == 0) {\r\n          return this._getDataAtNode(curr, prefix);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      } else {\r\n        curr = curr[letter];\r\n      }\r\n    }\r\n    return this._getDataAtNode(curr, prefix);\r\n  }\r\n}\r\n\r\nexport default TrieJS;\r\n","import TrieJS from \"./trie\";\r\nimport { defineComponent, h, PropType, nextTick } from 'vue'\r\ninterface FormatResult {\r\n  word: string;\r\n  prev: string;\r\n}\r\n\r\nconst dataFunction = async function(\r\n  word: string,\r\n  pos: number\r\n): Promise<string[]> {\r\n  return [];\r\n};\r\n\r\nconst formatFunction = (\r\n  word: string,\r\n  prev: string,\r\n  pos: number\r\n): FormatResult => ({ word, prev });\r\n\r\ninterface Data {\r\n  trie: TrieJS;\r\n  position: number;\r\n  wordPos: number;\r\n  index: number;\r\n  words: string[];\r\n  word: string;\r\n  possible: string[] | false;\r\n  saved: boolean;\r\n  localValue: string;\r\n  isTypeahead: boolean;\r\n}\r\n\r\nexport interface CompleteEvent {\r\n  original?: KeyboardEvent;\r\n  completions: string[] | false;\r\n  current: number;\r\n  word: string;\r\n}\r\n\r\nexport type FormatFunction = typeof formatFunction;\r\nexport type DataFunction = typeof dataFunction;\r\n\r\ntype DataFunctionProp = string[] | DataFunction;\r\n\r\nfunction isDataFunction(data: DataFunctionProp): data is DataFunction {\r\n  return !!(data as DataFunction).bind;\r\n}\r\n\r\nexport default defineComponent({\r\n  name: \"tab-complete-input\",\r\n\r\n  emits: [\r\n    \"tab-failed\",\r\n    \"tab-success\",\r\n    \"tab-ended\",\r\n    \"selection-changed\",\r\n    \"update:modelValue\"\r\n  ],\r\n\r\n  data() {\r\n    return {\r\n      trie: new TrieJS(),\r\n      position: 0,\r\n      wordPos: 0,\r\n      index: 0,\r\n      words: [],\r\n      word: \"\",\r\n      possible: false,\r\n      saved: false,\r\n      localValue: this.modelValue,\r\n      isTypeahead: false\r\n    } as Data;\r\n  },\r\n\r\n  render() {\r\n    const onKeydown: any[] = [this.tabComplete];\r\n\r\n    if (typeof this.$attrs.onKeydown === \"function\") {\r\n      onKeydown.push(this.$attrs.onKeydown);\r\n    }\r\n\r\n    if (Array.isArray(this.$attrs.onKeydown)) {\r\n      onKeydown.push(...this.$attrs.onKeydown);\r\n    }\r\n\r\n    return h(\"input\", {\r\n      ref: \"input\",\r\n      ...this.$props,\r\n      ...this.$attrs,\r\n      value: this.modelValue,\r\n      \"onUpdate:modelValue\": (value: string) => (this.localValue = value),\r\n      onKeydown,\r\n      onInput: (event: InputEvent) => {\r\n        const elem = event.target as HTMLInputElement;\r\n        this.updateValue(elem.value);\r\n        this.typeaheadCompletion();\r\n      }\r\n    });\r\n  },\r\n\r\n  created() {\r\n    if (!isDataFunction(this.dataSource)) {\r\n      this.setData(this.dataSource);\r\n    }\r\n  },\r\n\r\n  props: {\r\n    dataSource: {\r\n      default: (): string[] => []\r\n    },\r\n    format: {\r\n      type: Function as PropType<typeof formatFunction>,\r\n      default: formatFunction\r\n    },\r\n    modelValue: {\r\n      default: \"\"\r\n    },\r\n    startCompletionChar: {\r\n      default: \"@\"\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    // whenever dataSource changes, this function will run\r\n    dataSource(data: DataFunctionProp) {\r\n      if (!isDataFunction(data)) {\r\n        this.setData(data);\r\n      }\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    setData(array: string[]) {\r\n      this.trie = new TrieJS();\r\n      array.forEach(element => {\r\n        this.trie.add(element);\r\n      });\r\n    },\r\n\r\n    getCurrentWord() {\r\n      this.position = this.getCursorPos();\r\n      const newValue =\r\n        this.localValue.slice(0, this.position) +\r\n        \" \" +\r\n        this.localValue.slice(this.position);\r\n\r\n      this.words = newValue.split(\" \");\r\n      let lcount = 0;\r\n      for (let i = 0; i < this.words.length; i++) {\r\n        const w = this.words[i];\r\n        lcount += w.length + 1;\r\n        if (lcount >= this.position) {\r\n          this.word = this.words[i];\r\n          this.wordPos = i;\r\n          break;\r\n        }\r\n      }\r\n    },\r\n\r\n    async getCompletions(e?: KeyboardEvent) {\r\n      if (isDataFunction(this.dataSource)) {\r\n        const data = this.dataSource(this.word, this.wordPos);\r\n        const array = await data;\r\n        this.setData(array);\r\n      }\r\n\r\n      this.saved = true;\r\n      this.possible = this.trie.find(this.word);\r\n\r\n      this.emitEvents(e);\r\n    },\r\n\r\n    selectCompletion(index?: number) {\r\n      if (!this.possible) return;\r\n\r\n      if (index !== undefined && index < this.possible.length) {\r\n        this.index = index;\r\n      }\r\n\r\n      this.isTypeahead = false;\r\n\r\n      const dupe = this.words;\r\n      const completion = this.possible[this.index];\r\n      let prev = \"\";\r\n\r\n      if (dupe.length > 1) {\r\n        prev = dupe[this.wordPos - 1];\r\n      }\r\n\r\n      const res = this.format(completion, prev, this.wordPos);\r\n      dupe[this.wordPos] = res.word;\r\n      if (res.prev) dupe[this.wordPos - 1] = res.prev;\r\n\r\n      const newPos = this.words.slice(0, this.wordPos + 1).join(\" \").length;\r\n      this.localValue = dupe.join(\" \");\r\n      this.localValue =\r\n        this.localValue.slice(0, newPos) + this.localValue.slice(newPos + 1);\r\n      this.updateValue(this.localValue);\r\n      nextTick(() => this.selectRange(newPos, newPos));\r\n\r\n      const event: CompleteEvent = {\r\n        completions: this.possible,\r\n        word: this.word,\r\n        current: this.index\r\n      };\r\n\r\n      this.$emit(\"selection-changed\", event);\r\n    },\r\n\r\n    emitEvents(e?: KeyboardEvent) {\r\n      const event: CompleteEvent = {\r\n        original: e,\r\n        completions: this.possible,\r\n        word: this.word,\r\n        current: this.index\r\n      };\r\n\r\n      if (!this.possible) {\r\n        this.$emit(this.saved ? \"tab-failed\" : \"tab-ended\", event);\r\n      } else {\r\n        this.$emit(\"tab-success\", event);\r\n      }\r\n    },\r\n\r\n    async handleTabPressed(e?: KeyboardEvent) {\r\n      if (!this.saved) {\r\n        e?.preventDefault();\r\n        await this.getCompletions(e);\r\n      } else {\r\n        this.index++;\r\n      }\r\n\r\n      if (this.possible) {\r\n        e?.preventDefault();\r\n\r\n        if (this.index >= this.possible.length) {\r\n          this.index = 0;\r\n        }\r\n\r\n        this.selectCompletion();\r\n      }\r\n    },\r\n\r\n    async tabComplete(e: KeyboardEvent) {\r\n      if (!e) return;\r\n      this.getCurrentWord();\r\n\r\n      if (e.key === \"tab\" || e.keyCode === 9) {\r\n        await this.handleTabPressed(e);\r\n        return;\r\n      }\r\n\r\n      if (!this.isTypeahead) {\r\n        this.saved = false;\r\n        this.possible = false;\r\n        this.index = 0;\r\n\r\n        this.emitEvents(e);\r\n      }\r\n    },\r\n\r\n    async typeaheadCompletion() {\r\n      if (this.word.startsWith(this.startCompletionChar)) {\r\n        this.word = this.word.replace(this.startCompletionChar, \"\");\r\n        await this.getCompletions();\r\n\r\n        this.isTypeahead = true;\r\n\r\n        return;\r\n      }\r\n\r\n      if (this.isTypeahead) {\r\n        await this.getCompletions();\r\n\r\n        if (!this.possible) {\r\n          this.isTypeahead = false;\r\n        }\r\n      }\r\n    },\r\n\r\n    updateValue(value: string) {\r\n      this.localValue = value;\r\n      this.$emit(\"update:modelValue\", value);\r\n    },\r\n\r\n    selectRange(start: number, end: number) {\r\n      this.$el.focus();\r\n      this.$el.setSelectionRange(start, end);\r\n    },\r\n\r\n    getCursorPos() {\r\n      return this.$el.selectionStart;\r\n    }\r\n  }\r\n});\r\n"],"names":["defaultOptions","enableCache","insertOrder","returnRoot","TrieJS","opts","key","this","Object","prototype","hasOwnProperty","call","options","insert","target","item","_this","undefined","data","d","o","index","length","push","sort","a","b","clip","max","splice","copy","slice","merge","word","i","ii","_addCacheData","curr","root","$d","_addSuffix","suffix","letter","charAt","nextSuffix","substring","$s","_moveSuffix","_getDataAtNode","node","_getSubtree","_stripInsertOrder","temp","res","nodeArray","pop","newNode","add","arguments","toLowerCase","contains","find","prefix","indexOf","isDataFunction","bind","defineComponent","name","emits","trie","position","wordPos","words","possible","saved","localValue","modelValue","isTypeahead","render","onKeydown","tabComplete","$attrs","Array","isArray","h","ref","$props","value","onUpdate:modelValue","onInput","event","updateValue","typeaheadCompletion","created","dataSource","setData","props","default","format","type","Function","prev","pos","startCompletionChar","watch","methods","array","forEach","element","_this2","getCurrentWord","getCursorPos","newValue","split","lcount","getCompletions","e","_this4","emitEvents","selectCompletion","dupe","newPos","join","nextTick","_this5","selectRange","$emit","completions","current","original","handleTabPressed","_this7","preventDefault","_this9","keyCode","_this11","startsWith","replace","start","end","$el","focus","setSelectionRange","selectionStart"],"mappings":"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"}